{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenue","title":"Accueil"},{"location":"#bienvenue","text":"","title":"Bienvenue"},{"location":"java/","text":"Sommaire Bienvenue dans cette section concernant le monde Java. Plateforme Format binaire Organisation du code Convention Java Bean Documentation H\u00e9ritage Polymorphisme G\u00e9n\u00e9ricit\u00e9 Invocation dynamique Programmation Fonctionnelle Projet de synth\u00e8se: CRUD","title":"Sommaire"},{"location":"java/#sommaire","text":"Bienvenue dans cette section concernant le monde Java. Plateforme Format binaire Organisation du code Convention Java Bean Documentation H\u00e9ritage Polymorphisme G\u00e9n\u00e9ricit\u00e9 Invocation dynamique Programmation Fonctionnelle Projet de synth\u00e8se: CRUD","title":"Sommaire"},{"location":"java/functional_programming/","text":"Programmation Fonctionnelle Introduction La programmation fonctionnelle est un paradigme de programmation bas\u00e9 sur la notion de fonction et d'expression lambda . Elle est apparue en Java 1.8 . Pour mettre en \u0153uvre la programmation fonctionnelle en Java, nous utiliserons les concepts suivants : Les interfaces fonctionnelles Les m\u00e9thodes par d\u00e9fauts des interfaces Les expressions lambda. Interface fonctionnelle Une interface fonctionnelle est une interface qui ne poss\u00e8de qu'une seule m\u00e9thode abstraite. Mais elle peut poss\u00e9der plusieurs m\u00e9thodes concr\u00e8te par d\u00e9faut. Elle porte \u00e9galement l'annotation @FunctionalInterface . Exemple : @FunctionalInterface public interface MyFunction<T>{ void apply(T element); } De nombreuse interfaces fonctionnelles g\u00e9n\u00e9riques sont d\u00e9j\u00e0 pr\u00e9sentent dans Java pour couvrir les cas courants: Interface Type de retour Type en entr\u00e9e Commentaire Consumer void T Consomme une donn\u00e9e Supplier T void Produit une donn\u00e9e Predicate boolean T Pour construire une condition Function R T Fonction g\u00e9n\u00e9rique BiConsumer void T, U Variante du Consumer pour deux param\u00e8tres BiPredicate boolean T, U Variante du Predicate pour deux param\u00e8tres BiFunction R T, U Variante de Function pour deux param\u00e8tres Pour une liste plus exhaustive, voir le package java.util.function . Expression lambda Vous pouvez voir l'\u00e9crire d'une expression lambda comme une fa\u00e7on plus simple d'utiliser des classes anonymes. Mais son fonctionnement en interne est radicalement diff\u00e9rent. // Classe anonymes: // Cette \u00e9criture est ni \u00e9l\u00e9gante, ni \u00e9pur\u00e9e. // A EVITER ! Function<String, String> upper = new Function<>() { @Override public String apply(String t){ return t.toUpperCase(); } }; // Usage: var result = upper.apply(\"Hello world\"); // Sortie console: // HELLO WORLD Dans le code ci-dessus, la seule information r\u00e9ellement utile le traitement de la fonction apply . On peut donc r\u00e9duire l'\u00e9criture ainsi: // Expression lambda multi ligne. Function<String, String> upper0 = (String t) -> { ^^^^^^^^^^--------// // Param\u00e8tre de la fonction 'apply'. // L'instanciation n'est plus n\u00e9cessaire. // Le nom de la fonction n'est plus n\u00e9cessaire \u00e9galement. return t.toUpperCase(); // Le traitement est sur une ligne, on peut simplifier l'\u00e9criture. }; // Expression lambda en une ligne. Function<String, String> upper1 = t -> t.toUpperCase(); ^^^-------------------// // Param\u00e8tre de la fonction 'apply'. // Le type de 't' est inf\u00e9r\u00e9, il est port\u00e9 par le membre de gauche // on peut donc omettre le typage. // Les parenth\u00e8ses sont optionnelles car il n'y a qu'un seul param\u00e8tre. // Les accolades ne sont plus n\u00e9cessaire car le traitement tient en une ligne. // Passage par r\u00e9f\u00e9rence Function<String, String> upper2 = String::toUpperCase; ^^^^^^^^^^^^^----// // La fonction 'toUpperCase' est transtyper en 'apply'. // Le param\u00e8tre n'est plus n\u00e9cessaire, il sera r\u00e9solu // \u00e0 l'appel de la fonction. // C'est le principe d'application partielle. Lors de l'\u00e9criture d'une expression lambda privil\u00e9gier le passage par r\u00e9f\u00e9rence de fonction ou l'\u00e9criture sur une ligne. Les \u00e9critures en blocs sont \u00e0 \u00e9viter, cela signifie que vous pouvez extraire le bloc dans une autre fonction. Note Toutes les fonctions d'une classe peuvent \u00eatre pass\u00e9es par r\u00e9f\u00e9rence. Pour le constructeur la syntaxe est la suivante : MyClass::new . Concept Voici les principes fondamentaux de la programmation fonctionnelle : Fonction pure Transparence r\u00e9f\u00e9rentielle Fonction d'ordre sup\u00e9rieur \u00c9valuation paresseuse Application partielle Structure de donn\u00e9es immuables Note En Java nous ne ferons pas de distinction entre une m\u00e9thode et une fonction . Ce sont des synonymes. Fonction pure Une fonction pure, est une fonction qui ne produit pas d'effet de bord. Elle ne modifie pas son environnement. C'est-\u00e0-dire, pour des param\u00e8tres d'entr\u00e9es donn\u00e9es, la fonction produira toujours le m\u00eame r\u00e9sultat sans influencer son environnement. Exemple : // Fonction pure public int getUniversalAnswer(){ return 42; // Retourne toujours la valeur '42'. } // Fonction pure avec param\u00e8tres public int sum(final int a, final int b){ return a + b; // Retourne toujours la m\u00eame valeur // pour des m\u00eames param\u00e8tres d'entr\u00e9e. } // Fonction impure public int doSomething(int n){ var badDay = LocalDate.now().getDayOfWeek() == DayOfWeek.MONDAY; if(badDay){ throw new IllegalStateException(\"RAGE QUIT!\"); } // Effet de bord: // Cette fonction retourne un r\u00e9sultat diff\u00e9rent // en fonction du jour o\u00f9 elle est appel\u00e9e. return n * n; } // Fonction impure public void showUniversalAnswer(){ System.out.print(42); // Effet de bord: // Cette fonction modifie son environnement, // en l'occurrence l'\u00e9tat de la console. // // Sortie console au premier appel: 42 // Sortie console au deuxi\u00e8me appel: 4242 // Sortie console au troisi\u00e8me appel: 424242 // ... } Note L'effet de bord n'est pas quelque chose de fondamentalement mauvais, il faut simplement ma\u00eetriser son impact. Dans une application toutes les fonctions ne sont pas tenues d'\u00eatre des fonctions pures. Si une application ne produit pas d'effet de bord, c'est qu'elle ne fait rien. Transparence r\u00e9f\u00e9rentielle La transparence r\u00e9f\u00e9rentielle permet de consid\u00e9rer des fonctions pures comme des valeurs dans un algorithme. // Fonction pure public int getUniversalAnswer(){ return 42; } // Fonction pure public int sum(final int a, final int b){ return a + b; } // Fonction de traitement: public int doSomething(){ // Vision de la transparence r\u00e9f\u00e9rentielle: var x = getUniversalAnswer(); // Peut \u00eatre remplac\u00e9 par: 42 var y = sum(x, x); // Peut \u00eatre remplac\u00e9 par: 84 return x + y; } Note On peut directement remplacer une fonction par le r\u00e9sultat de celle-ci sans que cela ne perturbe l'algorithme. Fonction d'ordre sup\u00e9rieur Une fonction d'ordre sup\u00e9rieur est une fonction qui prend en param\u00e8tre une fonction et/ou qui retourne une fonction. Exemple : // Fonction d'ordre sup\u00e9rieur // Le param\u00e8tre 'Supplier' est une interface fonctionnelle Java (donc une fonction) public void doSomething(final Supplier<String> message){ // ... } // Fonction d'ordre sup\u00e9rieur // Le type de retour 'Consumer' est une interface fonctionnelle Java (donc une fonction) public Consumer<String> doSomething(){ // ... } \u00c9valuation paresseuse Ce concept va de pair avec les fonctions d'ordre sup\u00e9rieur, il permet d'obtenir le r\u00e9sultat d'une fonction le plus tard possible dans l'algorithme. Exemple : // Cas de la journalisation public void log(final Level level, Supplier<String> message){ ^^^^^^^^^^^^^^^^^^^^^^^^-----// // Fonction qui contient // une cha\u00eene de caract\u00e8res (potentiellement \u00e9norme). // Cette fonction n'est pas encore \u00e9valu\u00e9e, // ce qui permet de ne pas consommer de la ressource inutilement // notamment si le niveau de journalisation // ne permet pas d'enregistrement. if(isLoggable(level)){ ^^^^^^^^^^---// // V\u00e9rification du niveau de journalisation // Est-ce que ce niveau permet l'enregistrement ? // Cr\u00e9ation de l'enregistrement // pour la journalisation. var record = new LogRecord(level, message.get()); ^^^^^-----// \u00c9valuation de la fonction: // Cette fonction est invoqu\u00e9e \u00e0 ce moment-l\u00e0. // La ressource est effectivement utilis\u00e9e ici, // car le besoin est av\u00e9r\u00e9. doLog(record); // Faire l'enregistrement. } // Sinon: // Ce niveau de journalisation ne permet pas d'enregistrement // Pas besoin d'\u00e9valuer la fonction. // Pas de consommation de la ressource. } Application partielle Ce concept permet de manipuler des fonctions en r\u00e9solvant implicitement ou tardivement des param\u00e8tres. Exemple : // Cas nominal: Stream .of(\"a\", \"b\", \"c\", \"d\") .forEach(e -> System.out.println(e)); ^^^^^^^^^^----// La fonction 'forEach' prend en param\u00e8tre // un 'Consumer' peut \u00eatre r\u00e9solu avec une expression lambda. // On passe 'e' l'\u00e9l\u00e9ment d'it\u00e9ration de la fonction \u00e0 'println'. // Application partielle: Stream .of(\"a\", \"b\", \"c\", \"d\") .forEach(System.out::println); ^^^^^^^-----------// On passe cette fois directement la fonction 'println' // par r\u00e9f\u00e9rence. // On ne passe pas l'\u00e9l\u00e9ment d'it\u00e9ration de la fonction \u00e0 'println'. // L'application partielle permet de r\u00e9soudre le param\u00e8tre automatiquement. Note Le passage par r\u00e9f\u00e9rence de fonction en Java s'effectue avec la syntaxe :: . La fonction forEach prend en param\u00e8tre un type Consumer , Java est en mesure de transtyper ce param\u00e8tre avec la fonction println . Pour se faire la signature de la fonction Customer.accept et System.out.println doivent correspondre. Ce qui bien entendu le cas ici. Le nom de la fonction n'entre pas en compte lors du transtypage fonctionnel, seuls les param\u00e8tres d'entr\u00e9e et de sortie compte. Structure de donn\u00e9es immuables Comme une fonction pure ne doit pas produire d'effet de bord, il est donc logique que les objets pass\u00e9s en param\u00e8tres ne puissent pas \u00eatre modifi\u00e9 par r\u00e9f\u00e9rence. Il faut \u00e0 pr\u00e9sent consid\u00e9rer les objets manipul\u00e9s par ces fonctions comme des valeurs et non plus comme des r\u00e9f\u00e9rences. Pour se faire les objets seront immuables. Exemple : // Classe de donn\u00e9s immuables. // Impossible de changer l'\u00e9tat d'un objet apr\u00e8s instanciation. public final class Cutomer { // La classe 'java.lang.String' est immuable. // Les attributs sont initialis\u00e9s une et une seule fois lors de l'instanciation. public final String givenName; public final String familyName; public final String email; public Customer(final String givenName, final String familyName, final String email){ this.givenName = givenName; this.familyName = familyName; this.email = email; } // equals, hashCode et toString sur tous les attributs // ... // Accesseurs // ... // PAS DE MUTATEURS ! // Si on souhaite changer l'\u00e9tat de cet objet, il faut en instancier un nouveau \u00e0 chaque fois // Solution possible \u00e0 la place des mutateurs: public Customer withGivenName(final String givenName){ return new Customer(givenName, this.familyName, this.email); } public Customer withFamilyName(final String familyName){ return new Customer(this.givenName, familyName, this.email); } public Customer withEmail(final String email){ return new Customer(this.givenName, this.familyName, email); } } Un objet immuable ne produit pas d'effet de bord lorsqu'il est manipul\u00e9. Un objet immuable n'est pas soumis au probl\u00e8me d'acc\u00e8s concurrentiel (thread-safe) . Note Effectivement, la JVM est oblig\u00e9e de faire une nouvelle allocation m\u00e9moire pour chaque instanciation. G\u00e9n\u00e9ralement ce type d'objet immuable poss\u00e8de un cycle de vie assez court, ce qui n'est pas un probl\u00e8me. Le m\u00e9canisme de ramasse miette sait tr\u00e8s bien g\u00e9rer ce cas de figure. Cas pratique avanc\u00e9 Objectif On souhaite r\u00e9aliser un validateur d'objet de donn\u00e9es g\u00e9n\u00e9rique en pure Java avec l'approche fonctionnelle. Structure de donn\u00e9es // Exemple complet. // Classe de donn\u00e9s immuable. public final class Cutomer { public final String givenName; public final String familyName; public final String email; public Customer(final String givenName, final String familyName, final String email){ this.givenName = givenName; this.familyName = familyName; this.email = email; } public int hashCode(){ return Objects.hash(givenName, familyName, email); } public boolean equals(Object obj){ boolean eq; if (this == obj){ eq = true; }else if(!(obj instanceof Customer)){ eq = false; }else{ var other = (Customer) obj; eq = Objects.equals(this.givenName, other.givenName) && Objects.equals(this.familyName, other.familyName) && Objects.equals(this.email, other.email); } return eq; } public String toString(){ return String.format( \"%s{givenName=%s, familyName=%s, email=%s}\", getClass().getName(), this.givenName, this.familyName, this.email ); } public String getGivenName() { return givenName; } public Customer withGivenName(final String givenName){ return new Customer(givenName, this.familyName, this.email); } public String getFamilyName() { return familyName; } public Customer withFamilyName(final String familyName){ return new Customer(this.givenName, familyName, this.email); } public String getEmail() { return email; } public Customer withEmail(final String email){ return new Customer(this.givenName, this.familyName, email); } } Note Pour ce cas pratique, n'importe quelle classe de donn\u00e9es peut faire l'affaire. Si un objet n'est pas valide, la validation produira une exception. Classe d'exception public class ValidationException extends RuntimeException { private static final long serialVersionUID = 1L; ValidationException(String message) { super(message); } } Classe du Validateur // On applique la g\u00e9n\u00e9ricit\u00e9 pour que cette classe travail avec n'importe quelle type d'instance. // Patron de conception: 'Monad'. public final class Validator<T> { // Instance d'objet de donn\u00e9es \u00e0 valider. private final T target; // Liste de toutes les erreurs de validation. private final List<ValidationException> exceptions; // Constructeur priv\u00e9 // Ce constructeur sera encapsul\u00e9 dans une m\u00e9thode fabrique. private Validator(final T target) { this.target = target; this.exceptions = new ArrayList<>(); } // M\u00e9thode de fabrique. // Plus \u00e9l\u00e9gant pour cha\u00eener les appels de m\u00e9thodes. public static <T> Validator<T> of(final T target) { return new Validator<>(target); } // M\u00e9thode de validation // 1er param\u00e8tre: Clause conditionnelle de validation. // 2nd param\u00e8tre: Message d'erreur si la condition \u00e9choue. public Validator<T> validate(final Predicate<T> predicate, final String message) { // Exemple de pr\u00e9dicat: // ???.getEmail() != null // Le r\u00e9sultat de cette op\u00e9ration renvoie bien une valeur bool\u00e9enne. // O\u00f9 ??? doit \u00eatre un objet de type T. (conf\u00e8re g\u00e9n\u00e9ricit\u00e9) // \u00c9valuation paresseuse du pr\u00e9dicat. // Si le test \u00e9choue, // on cr\u00e9e une exception et on l'ajoute \u00e0 la liste. // On ne l\u00e8ve pas l'exception maintenant // car on souhaite tester l'int\u00e9gralit\u00e9 de l'objet avant la lev\u00e9e d'exception. if (!predicate.test(target)) { exceptions.add(new ValidationException(message)); } // Pour cha\u00eener les appels, on retourne l'instance du validateur courant. return this; } // M\u00e9thode de validation // C'est fois-ci, on utilise le concept d'application partielle. // 1er param\u00e8tre: Fonction g\u00e9n\u00e9rique permettant d'acc\u00e9der \u00e0 une propri\u00e9t\u00e9 de l'objet. // 2e param\u00e8tre: Clause conditionnelle de validation. // 3e param\u00e8tre: Message d'erreur si la condition \u00e9choue. public <R> Validator<T> validate( final Function<T, R> projection, final Predicate<R> predicate, final String message) { // Exemple de projection: // ???.getEmail() // On r\u00e9cup\u00e8re ici simple une fonction de l'objet \u00e0 valider. // O\u00f9 ??? doit \u00eatre un objet de type T. (conf\u00e8re g\u00e9n\u00e9ricit\u00e9) // Exemple de pr\u00e9dicat: // ??? != null // Un simple condition, ici doit \u00eatre diff\u00e9rent de nul. // O\u00f9 ??? doit \u00eatre un objet de type R. (conf\u00e8re g\u00e9n\u00e9ricit\u00e9) // Ci-dessous, avec l'application partielle, on r\u00e9alise \u00e9galement de la composition de fonction // Ce qui permet d'associer la projection et le pr\u00e9dicat: // ???.getEmail() != null // Or ce r\u00e9sultat est lui-m\u00eame un pr\u00e9dicat // On peut donc rappeler la fonction 'validate' ci-dessus. return validate(projection.andThen(predicate::test)::apply, message); } // Enfin, on peut d\u00e9s-encapsuler l'objet initial et lever les exceptions si existantes. public T get() { // Si l'objet poss\u00e8de des exceptions... if (!exceptions.isEmpty()) { // On cr\u00e9e une exception racine ValidationException exception = new ValidationException(\"Validation failed\"); // Puis on concat\u00e8ne les autres exceptions \u00e0 la racine // Cela permet d'avoir les messages de tous les champs invalides // dans une seule trace. exceptions.forEach(exception::addSuppressed); throw exception; } // On retourne l'objet initial. return target; } } Approche par pr\u00e9dicat Mise en \u0153uvre : // Expression r\u00e9guli\u00e8re simple pour adresse de courriel. String emailRegEx = \"^[\\\\w-\\\\+]+(\\\\.[\\\\w]+)*@[\\\\w-]+(\\\\.[\\\\w]+)*(\\\\.[a-z]{2,})$\"; Pattern pattern = Pattern.compile(emailRegEx, Pattern.CASE_INSENSITIVE); Customer enity = new Customer(\"John\", \"DOE\", \"john.doe@sample.org\"); // Approche par pr\u00e9dicat: Validator .of(entity) .validate(e -> Objects.nonNull(e.getGivenName()), \"Le pr\u00e9nom est obligatoire\") .validate(e -> Objects.nonNull(e.getFamilyName()), \"Le nom de famille est obligatoire\") .validate(e -> Objects.nonNull(e.getEmail()), \"L'adresse de courriel est obligatoire\") .validate(e -> pattern.matcher(e.getEmail()).matches(), \"Format d'adresse de courriel invalide\") .get(); Approche par r\u00e9f\u00e9rence de fonction Mise en \u0153uvre : Customer enity = new Customer(\"John\", \"DOE\", \"john.doe@sample.org\"); // Approche par r\u00e9f\u00e9rence de fonction: Validator .of(entity) .validate(Customer::getGivenName, Objects::nonNull, \"Le pr\u00e9nom est obligatoire\") .validate(Customer::getFamilyName, Objects::nonNull, \"Le nom de famille est obligatoire\") .validate(Customer::getEmail, Objects::nonNull, \"L'adresse de courriel est obligatoire\") .validate(Customer::getEmail, this::checkEmail, \"Format d'adresse de courriel invalide\") .get(); // Cette petite m\u00e9thode est pour faciliter l\u2019\u00e9criture. private boolean checkEmail(String email){ boolean check; if(Objects.isNull(email)){ checked = false; }else{ String emailRegEx = \"^[\\\\w-\\\\+]+(\\\\.[\\\\w]+)*@[\\\\w-]+(\\\\.[\\\\w]+)*(\\\\.[a-z]{2,})$\"; Pattern pattern = Pattern.compile(emailRegEx, Pattern.CASE_INSENSITIVE); checked = pattern.matcher(email).matches(); } return checked; } Cas d'exception Mise en \u0153uvre : // Cas d'un objet invalide: Customer fake = new Customer(null, null, \"john.doe\"); Validator .of(fake) .validate(Customer::getGivenName, Objects::nonNull, \"Le pr\u00e9nom est obligatoire\") .validate(Customer::getFamilyName, Objects::nonNull, \"Le nom de famille est obligatoire\") .validate(Customer::getEmail, Objects::nonNull, \"L'adresse de courriel est obligatoire\") .validate(Customer::getEmail, this::checkEmail, \"Format d'adresse de courriel invalide\") .get(); // Sortie console: //> Statck Trace // // Exception in thread \"main\" fr.zelmoacademy.util.validation.ValidationException: Validation failed // at fr.zelmoacademy.util.validation.Validator.get(Validator.java:XX) // at fr.zelmoacademy.Launcher.main(Launcher.java:XX) // Suppressed: fr.zelmoacademy.validation.ValidationException: Le pr\u00e9nom est obligatoire // at fr.zelmoacademy.util.validation.Validator.validate(Validator.java:XX) // at fr.zelmoacademy.Launcher.main(Launcher.java:XX) // Suppressed: fr.zelmoacademy.validation.ValidationException: Le nom de famille est obligatoire // at fr.zelmoacademy.util.validation.Validator.validate(Validator.java:XX) // at fr.zelmoacademy.Launcher.main(Launcher.java:XX) // Suppressed: fr.zelmoacademy.validation.ValidationException: Format d'adresse de courriel invalide // at fr.zelmoacademy.util.validation.Validator.validate(Validator.java:XX) // at fr.zelmoacademy.Launcher.main(Launcher.java:XX) Axe d'am\u00e9lioration On peut cr\u00e9er une classe utilitaire avec plein de m\u00e9thode statique pour les pr\u00e9dicats tel que checkEmail . Ceci permettrait de cr\u00e9er du code r\u00e9utilisable facilement. Si vous examinez attentivement la classe Validator<T> vous constaterez que les fonctions ne sont pas pures. a votre avis comment corriger cela ? Note Malgr\u00e9 le passage par r\u00e9f\u00e9rence et l'application partielle, le compilateur est en mesure de r\u00e9soudre le typage statique de Java par inf\u00e9rence. Pas de probl\u00e8me de ce c\u00f4t\u00e9-l\u00e0.","title":"Programmation fonctionnelle"},{"location":"java/functional_programming/#programmation-fonctionnelle","text":"","title":"Programmation Fonctionnelle"},{"location":"java/functional_programming/#introduction","text":"La programmation fonctionnelle est un paradigme de programmation bas\u00e9 sur la notion de fonction et d'expression lambda . Elle est apparue en Java 1.8 . Pour mettre en \u0153uvre la programmation fonctionnelle en Java, nous utiliserons les concepts suivants : Les interfaces fonctionnelles Les m\u00e9thodes par d\u00e9fauts des interfaces Les expressions lambda.","title":"Introduction"},{"location":"java/functional_programming/#interface-fonctionnelle","text":"Une interface fonctionnelle est une interface qui ne poss\u00e8de qu'une seule m\u00e9thode abstraite. Mais elle peut poss\u00e9der plusieurs m\u00e9thodes concr\u00e8te par d\u00e9faut. Elle porte \u00e9galement l'annotation @FunctionalInterface . Exemple : @FunctionalInterface public interface MyFunction<T>{ void apply(T element); } De nombreuse interfaces fonctionnelles g\u00e9n\u00e9riques sont d\u00e9j\u00e0 pr\u00e9sentent dans Java pour couvrir les cas courants: Interface Type de retour Type en entr\u00e9e Commentaire Consumer void T Consomme une donn\u00e9e Supplier T void Produit une donn\u00e9e Predicate boolean T Pour construire une condition Function R T Fonction g\u00e9n\u00e9rique BiConsumer void T, U Variante du Consumer pour deux param\u00e8tres BiPredicate boolean T, U Variante du Predicate pour deux param\u00e8tres BiFunction R T, U Variante de Function pour deux param\u00e8tres Pour une liste plus exhaustive, voir le package java.util.function .","title":"Interface fonctionnelle"},{"location":"java/functional_programming/#expression-lambda","text":"Vous pouvez voir l'\u00e9crire d'une expression lambda comme une fa\u00e7on plus simple d'utiliser des classes anonymes. Mais son fonctionnement en interne est radicalement diff\u00e9rent. // Classe anonymes: // Cette \u00e9criture est ni \u00e9l\u00e9gante, ni \u00e9pur\u00e9e. // A EVITER ! Function<String, String> upper = new Function<>() { @Override public String apply(String t){ return t.toUpperCase(); } }; // Usage: var result = upper.apply(\"Hello world\"); // Sortie console: // HELLO WORLD Dans le code ci-dessus, la seule information r\u00e9ellement utile le traitement de la fonction apply . On peut donc r\u00e9duire l'\u00e9criture ainsi: // Expression lambda multi ligne. Function<String, String> upper0 = (String t) -> { ^^^^^^^^^^--------// // Param\u00e8tre de la fonction 'apply'. // L'instanciation n'est plus n\u00e9cessaire. // Le nom de la fonction n'est plus n\u00e9cessaire \u00e9galement. return t.toUpperCase(); // Le traitement est sur une ligne, on peut simplifier l'\u00e9criture. }; // Expression lambda en une ligne. Function<String, String> upper1 = t -> t.toUpperCase(); ^^^-------------------// // Param\u00e8tre de la fonction 'apply'. // Le type de 't' est inf\u00e9r\u00e9, il est port\u00e9 par le membre de gauche // on peut donc omettre le typage. // Les parenth\u00e8ses sont optionnelles car il n'y a qu'un seul param\u00e8tre. // Les accolades ne sont plus n\u00e9cessaire car le traitement tient en une ligne. // Passage par r\u00e9f\u00e9rence Function<String, String> upper2 = String::toUpperCase; ^^^^^^^^^^^^^----// // La fonction 'toUpperCase' est transtyper en 'apply'. // Le param\u00e8tre n'est plus n\u00e9cessaire, il sera r\u00e9solu // \u00e0 l'appel de la fonction. // C'est le principe d'application partielle. Lors de l'\u00e9criture d'une expression lambda privil\u00e9gier le passage par r\u00e9f\u00e9rence de fonction ou l'\u00e9criture sur une ligne. Les \u00e9critures en blocs sont \u00e0 \u00e9viter, cela signifie que vous pouvez extraire le bloc dans une autre fonction. Note Toutes les fonctions d'une classe peuvent \u00eatre pass\u00e9es par r\u00e9f\u00e9rence. Pour le constructeur la syntaxe est la suivante : MyClass::new .","title":"Expression lambda"},{"location":"java/functional_programming/#concept","text":"Voici les principes fondamentaux de la programmation fonctionnelle : Fonction pure Transparence r\u00e9f\u00e9rentielle Fonction d'ordre sup\u00e9rieur \u00c9valuation paresseuse Application partielle Structure de donn\u00e9es immuables Note En Java nous ne ferons pas de distinction entre une m\u00e9thode et une fonction . Ce sont des synonymes.","title":"Concept"},{"location":"java/functional_programming/#fonction-pure","text":"Une fonction pure, est une fonction qui ne produit pas d'effet de bord. Elle ne modifie pas son environnement. C'est-\u00e0-dire, pour des param\u00e8tres d'entr\u00e9es donn\u00e9es, la fonction produira toujours le m\u00eame r\u00e9sultat sans influencer son environnement. Exemple : // Fonction pure public int getUniversalAnswer(){ return 42; // Retourne toujours la valeur '42'. } // Fonction pure avec param\u00e8tres public int sum(final int a, final int b){ return a + b; // Retourne toujours la m\u00eame valeur // pour des m\u00eames param\u00e8tres d'entr\u00e9e. } // Fonction impure public int doSomething(int n){ var badDay = LocalDate.now().getDayOfWeek() == DayOfWeek.MONDAY; if(badDay){ throw new IllegalStateException(\"RAGE QUIT!\"); } // Effet de bord: // Cette fonction retourne un r\u00e9sultat diff\u00e9rent // en fonction du jour o\u00f9 elle est appel\u00e9e. return n * n; } // Fonction impure public void showUniversalAnswer(){ System.out.print(42); // Effet de bord: // Cette fonction modifie son environnement, // en l'occurrence l'\u00e9tat de la console. // // Sortie console au premier appel: 42 // Sortie console au deuxi\u00e8me appel: 4242 // Sortie console au troisi\u00e8me appel: 424242 // ... } Note L'effet de bord n'est pas quelque chose de fondamentalement mauvais, il faut simplement ma\u00eetriser son impact. Dans une application toutes les fonctions ne sont pas tenues d'\u00eatre des fonctions pures. Si une application ne produit pas d'effet de bord, c'est qu'elle ne fait rien.","title":"Fonction pure"},{"location":"java/functional_programming/#transparence-referentielle","text":"La transparence r\u00e9f\u00e9rentielle permet de consid\u00e9rer des fonctions pures comme des valeurs dans un algorithme. // Fonction pure public int getUniversalAnswer(){ return 42; } // Fonction pure public int sum(final int a, final int b){ return a + b; } // Fonction de traitement: public int doSomething(){ // Vision de la transparence r\u00e9f\u00e9rentielle: var x = getUniversalAnswer(); // Peut \u00eatre remplac\u00e9 par: 42 var y = sum(x, x); // Peut \u00eatre remplac\u00e9 par: 84 return x + y; } Note On peut directement remplacer une fonction par le r\u00e9sultat de celle-ci sans que cela ne perturbe l'algorithme.","title":"Transparence r\u00e9f\u00e9rentielle"},{"location":"java/functional_programming/#fonction-dordre-superieur","text":"Une fonction d'ordre sup\u00e9rieur est une fonction qui prend en param\u00e8tre une fonction et/ou qui retourne une fonction. Exemple : // Fonction d'ordre sup\u00e9rieur // Le param\u00e8tre 'Supplier' est une interface fonctionnelle Java (donc une fonction) public void doSomething(final Supplier<String> message){ // ... } // Fonction d'ordre sup\u00e9rieur // Le type de retour 'Consumer' est une interface fonctionnelle Java (donc une fonction) public Consumer<String> doSomething(){ // ... }","title":"Fonction d'ordre sup\u00e9rieur"},{"location":"java/functional_programming/#evaluation-paresseuse","text":"Ce concept va de pair avec les fonctions d'ordre sup\u00e9rieur, il permet d'obtenir le r\u00e9sultat d'une fonction le plus tard possible dans l'algorithme. Exemple : // Cas de la journalisation public void log(final Level level, Supplier<String> message){ ^^^^^^^^^^^^^^^^^^^^^^^^-----// // Fonction qui contient // une cha\u00eene de caract\u00e8res (potentiellement \u00e9norme). // Cette fonction n'est pas encore \u00e9valu\u00e9e, // ce qui permet de ne pas consommer de la ressource inutilement // notamment si le niveau de journalisation // ne permet pas d'enregistrement. if(isLoggable(level)){ ^^^^^^^^^^---// // V\u00e9rification du niveau de journalisation // Est-ce que ce niveau permet l'enregistrement ? // Cr\u00e9ation de l'enregistrement // pour la journalisation. var record = new LogRecord(level, message.get()); ^^^^^-----// \u00c9valuation de la fonction: // Cette fonction est invoqu\u00e9e \u00e0 ce moment-l\u00e0. // La ressource est effectivement utilis\u00e9e ici, // car le besoin est av\u00e9r\u00e9. doLog(record); // Faire l'enregistrement. } // Sinon: // Ce niveau de journalisation ne permet pas d'enregistrement // Pas besoin d'\u00e9valuer la fonction. // Pas de consommation de la ressource. }","title":"\u00c9valuation paresseuse"},{"location":"java/functional_programming/#application-partielle","text":"Ce concept permet de manipuler des fonctions en r\u00e9solvant implicitement ou tardivement des param\u00e8tres. Exemple : // Cas nominal: Stream .of(\"a\", \"b\", \"c\", \"d\") .forEach(e -> System.out.println(e)); ^^^^^^^^^^----// La fonction 'forEach' prend en param\u00e8tre // un 'Consumer' peut \u00eatre r\u00e9solu avec une expression lambda. // On passe 'e' l'\u00e9l\u00e9ment d'it\u00e9ration de la fonction \u00e0 'println'. // Application partielle: Stream .of(\"a\", \"b\", \"c\", \"d\") .forEach(System.out::println); ^^^^^^^-----------// On passe cette fois directement la fonction 'println' // par r\u00e9f\u00e9rence. // On ne passe pas l'\u00e9l\u00e9ment d'it\u00e9ration de la fonction \u00e0 'println'. // L'application partielle permet de r\u00e9soudre le param\u00e8tre automatiquement. Note Le passage par r\u00e9f\u00e9rence de fonction en Java s'effectue avec la syntaxe :: . La fonction forEach prend en param\u00e8tre un type Consumer , Java est en mesure de transtyper ce param\u00e8tre avec la fonction println . Pour se faire la signature de la fonction Customer.accept et System.out.println doivent correspondre. Ce qui bien entendu le cas ici. Le nom de la fonction n'entre pas en compte lors du transtypage fonctionnel, seuls les param\u00e8tres d'entr\u00e9e et de sortie compte.","title":"Application partielle"},{"location":"java/functional_programming/#structure-de-donnees-immuables","text":"Comme une fonction pure ne doit pas produire d'effet de bord, il est donc logique que les objets pass\u00e9s en param\u00e8tres ne puissent pas \u00eatre modifi\u00e9 par r\u00e9f\u00e9rence. Il faut \u00e0 pr\u00e9sent consid\u00e9rer les objets manipul\u00e9s par ces fonctions comme des valeurs et non plus comme des r\u00e9f\u00e9rences. Pour se faire les objets seront immuables. Exemple : // Classe de donn\u00e9s immuables. // Impossible de changer l'\u00e9tat d'un objet apr\u00e8s instanciation. public final class Cutomer { // La classe 'java.lang.String' est immuable. // Les attributs sont initialis\u00e9s une et une seule fois lors de l'instanciation. public final String givenName; public final String familyName; public final String email; public Customer(final String givenName, final String familyName, final String email){ this.givenName = givenName; this.familyName = familyName; this.email = email; } // equals, hashCode et toString sur tous les attributs // ... // Accesseurs // ... // PAS DE MUTATEURS ! // Si on souhaite changer l'\u00e9tat de cet objet, il faut en instancier un nouveau \u00e0 chaque fois // Solution possible \u00e0 la place des mutateurs: public Customer withGivenName(final String givenName){ return new Customer(givenName, this.familyName, this.email); } public Customer withFamilyName(final String familyName){ return new Customer(this.givenName, familyName, this.email); } public Customer withEmail(final String email){ return new Customer(this.givenName, this.familyName, email); } } Un objet immuable ne produit pas d'effet de bord lorsqu'il est manipul\u00e9. Un objet immuable n'est pas soumis au probl\u00e8me d'acc\u00e8s concurrentiel (thread-safe) . Note Effectivement, la JVM est oblig\u00e9e de faire une nouvelle allocation m\u00e9moire pour chaque instanciation. G\u00e9n\u00e9ralement ce type d'objet immuable poss\u00e8de un cycle de vie assez court, ce qui n'est pas un probl\u00e8me. Le m\u00e9canisme de ramasse miette sait tr\u00e8s bien g\u00e9rer ce cas de figure.","title":"Structure de donn\u00e9es immuables"},{"location":"java/functional_programming/#cas-pratique-avance","text":"","title":"Cas pratique avanc\u00e9"},{"location":"java/functional_programming/#objectif","text":"On souhaite r\u00e9aliser un validateur d'objet de donn\u00e9es g\u00e9n\u00e9rique en pure Java avec l'approche fonctionnelle.","title":"Objectif"},{"location":"java/functional_programming/#structure-de-donnees","text":"// Exemple complet. // Classe de donn\u00e9s immuable. public final class Cutomer { public final String givenName; public final String familyName; public final String email; public Customer(final String givenName, final String familyName, final String email){ this.givenName = givenName; this.familyName = familyName; this.email = email; } public int hashCode(){ return Objects.hash(givenName, familyName, email); } public boolean equals(Object obj){ boolean eq; if (this == obj){ eq = true; }else if(!(obj instanceof Customer)){ eq = false; }else{ var other = (Customer) obj; eq = Objects.equals(this.givenName, other.givenName) && Objects.equals(this.familyName, other.familyName) && Objects.equals(this.email, other.email); } return eq; } public String toString(){ return String.format( \"%s{givenName=%s, familyName=%s, email=%s}\", getClass().getName(), this.givenName, this.familyName, this.email ); } public String getGivenName() { return givenName; } public Customer withGivenName(final String givenName){ return new Customer(givenName, this.familyName, this.email); } public String getFamilyName() { return familyName; } public Customer withFamilyName(final String familyName){ return new Customer(this.givenName, familyName, this.email); } public String getEmail() { return email; } public Customer withEmail(final String email){ return new Customer(this.givenName, this.familyName, email); } } Note Pour ce cas pratique, n'importe quelle classe de donn\u00e9es peut faire l'affaire. Si un objet n'est pas valide, la validation produira une exception.","title":"Structure de donn\u00e9es"},{"location":"java/functional_programming/#classe-dexception","text":"public class ValidationException extends RuntimeException { private static final long serialVersionUID = 1L; ValidationException(String message) { super(message); } }","title":"Classe d'exception"},{"location":"java/functional_programming/#classe-du-validateur","text":"// On applique la g\u00e9n\u00e9ricit\u00e9 pour que cette classe travail avec n'importe quelle type d'instance. // Patron de conception: 'Monad'. public final class Validator<T> { // Instance d'objet de donn\u00e9es \u00e0 valider. private final T target; // Liste de toutes les erreurs de validation. private final List<ValidationException> exceptions; // Constructeur priv\u00e9 // Ce constructeur sera encapsul\u00e9 dans une m\u00e9thode fabrique. private Validator(final T target) { this.target = target; this.exceptions = new ArrayList<>(); } // M\u00e9thode de fabrique. // Plus \u00e9l\u00e9gant pour cha\u00eener les appels de m\u00e9thodes. public static <T> Validator<T> of(final T target) { return new Validator<>(target); } // M\u00e9thode de validation // 1er param\u00e8tre: Clause conditionnelle de validation. // 2nd param\u00e8tre: Message d'erreur si la condition \u00e9choue. public Validator<T> validate(final Predicate<T> predicate, final String message) { // Exemple de pr\u00e9dicat: // ???.getEmail() != null // Le r\u00e9sultat de cette op\u00e9ration renvoie bien une valeur bool\u00e9enne. // O\u00f9 ??? doit \u00eatre un objet de type T. (conf\u00e8re g\u00e9n\u00e9ricit\u00e9) // \u00c9valuation paresseuse du pr\u00e9dicat. // Si le test \u00e9choue, // on cr\u00e9e une exception et on l'ajoute \u00e0 la liste. // On ne l\u00e8ve pas l'exception maintenant // car on souhaite tester l'int\u00e9gralit\u00e9 de l'objet avant la lev\u00e9e d'exception. if (!predicate.test(target)) { exceptions.add(new ValidationException(message)); } // Pour cha\u00eener les appels, on retourne l'instance du validateur courant. return this; } // M\u00e9thode de validation // C'est fois-ci, on utilise le concept d'application partielle. // 1er param\u00e8tre: Fonction g\u00e9n\u00e9rique permettant d'acc\u00e9der \u00e0 une propri\u00e9t\u00e9 de l'objet. // 2e param\u00e8tre: Clause conditionnelle de validation. // 3e param\u00e8tre: Message d'erreur si la condition \u00e9choue. public <R> Validator<T> validate( final Function<T, R> projection, final Predicate<R> predicate, final String message) { // Exemple de projection: // ???.getEmail() // On r\u00e9cup\u00e8re ici simple une fonction de l'objet \u00e0 valider. // O\u00f9 ??? doit \u00eatre un objet de type T. (conf\u00e8re g\u00e9n\u00e9ricit\u00e9) // Exemple de pr\u00e9dicat: // ??? != null // Un simple condition, ici doit \u00eatre diff\u00e9rent de nul. // O\u00f9 ??? doit \u00eatre un objet de type R. (conf\u00e8re g\u00e9n\u00e9ricit\u00e9) // Ci-dessous, avec l'application partielle, on r\u00e9alise \u00e9galement de la composition de fonction // Ce qui permet d'associer la projection et le pr\u00e9dicat: // ???.getEmail() != null // Or ce r\u00e9sultat est lui-m\u00eame un pr\u00e9dicat // On peut donc rappeler la fonction 'validate' ci-dessus. return validate(projection.andThen(predicate::test)::apply, message); } // Enfin, on peut d\u00e9s-encapsuler l'objet initial et lever les exceptions si existantes. public T get() { // Si l'objet poss\u00e8de des exceptions... if (!exceptions.isEmpty()) { // On cr\u00e9e une exception racine ValidationException exception = new ValidationException(\"Validation failed\"); // Puis on concat\u00e8ne les autres exceptions \u00e0 la racine // Cela permet d'avoir les messages de tous les champs invalides // dans une seule trace. exceptions.forEach(exception::addSuppressed); throw exception; } // On retourne l'objet initial. return target; } }","title":"Classe du Validateur"},{"location":"java/functional_programming/#approche-par-predicat","text":"Mise en \u0153uvre : // Expression r\u00e9guli\u00e8re simple pour adresse de courriel. String emailRegEx = \"^[\\\\w-\\\\+]+(\\\\.[\\\\w]+)*@[\\\\w-]+(\\\\.[\\\\w]+)*(\\\\.[a-z]{2,})$\"; Pattern pattern = Pattern.compile(emailRegEx, Pattern.CASE_INSENSITIVE); Customer enity = new Customer(\"John\", \"DOE\", \"john.doe@sample.org\"); // Approche par pr\u00e9dicat: Validator .of(entity) .validate(e -> Objects.nonNull(e.getGivenName()), \"Le pr\u00e9nom est obligatoire\") .validate(e -> Objects.nonNull(e.getFamilyName()), \"Le nom de famille est obligatoire\") .validate(e -> Objects.nonNull(e.getEmail()), \"L'adresse de courriel est obligatoire\") .validate(e -> pattern.matcher(e.getEmail()).matches(), \"Format d'adresse de courriel invalide\") .get();","title":"Approche par pr\u00e9dicat"},{"location":"java/functional_programming/#approche-par-reference-de-fonction","text":"Mise en \u0153uvre : Customer enity = new Customer(\"John\", \"DOE\", \"john.doe@sample.org\"); // Approche par r\u00e9f\u00e9rence de fonction: Validator .of(entity) .validate(Customer::getGivenName, Objects::nonNull, \"Le pr\u00e9nom est obligatoire\") .validate(Customer::getFamilyName, Objects::nonNull, \"Le nom de famille est obligatoire\") .validate(Customer::getEmail, Objects::nonNull, \"L'adresse de courriel est obligatoire\") .validate(Customer::getEmail, this::checkEmail, \"Format d'adresse de courriel invalide\") .get(); // Cette petite m\u00e9thode est pour faciliter l\u2019\u00e9criture. private boolean checkEmail(String email){ boolean check; if(Objects.isNull(email)){ checked = false; }else{ String emailRegEx = \"^[\\\\w-\\\\+]+(\\\\.[\\\\w]+)*@[\\\\w-]+(\\\\.[\\\\w]+)*(\\\\.[a-z]{2,})$\"; Pattern pattern = Pattern.compile(emailRegEx, Pattern.CASE_INSENSITIVE); checked = pattern.matcher(email).matches(); } return checked; }","title":"Approche par r\u00e9f\u00e9rence de fonction"},{"location":"java/functional_programming/#cas-dexception","text":"Mise en \u0153uvre : // Cas d'un objet invalide: Customer fake = new Customer(null, null, \"john.doe\"); Validator .of(fake) .validate(Customer::getGivenName, Objects::nonNull, \"Le pr\u00e9nom est obligatoire\") .validate(Customer::getFamilyName, Objects::nonNull, \"Le nom de famille est obligatoire\") .validate(Customer::getEmail, Objects::nonNull, \"L'adresse de courriel est obligatoire\") .validate(Customer::getEmail, this::checkEmail, \"Format d'adresse de courriel invalide\") .get(); // Sortie console: //> Statck Trace // // Exception in thread \"main\" fr.zelmoacademy.util.validation.ValidationException: Validation failed // at fr.zelmoacademy.util.validation.Validator.get(Validator.java:XX) // at fr.zelmoacademy.Launcher.main(Launcher.java:XX) // Suppressed: fr.zelmoacademy.validation.ValidationException: Le pr\u00e9nom est obligatoire // at fr.zelmoacademy.util.validation.Validator.validate(Validator.java:XX) // at fr.zelmoacademy.Launcher.main(Launcher.java:XX) // Suppressed: fr.zelmoacademy.validation.ValidationException: Le nom de famille est obligatoire // at fr.zelmoacademy.util.validation.Validator.validate(Validator.java:XX) // at fr.zelmoacademy.Launcher.main(Launcher.java:XX) // Suppressed: fr.zelmoacademy.validation.ValidationException: Format d'adresse de courriel invalide // at fr.zelmoacademy.util.validation.Validator.validate(Validator.java:XX) // at fr.zelmoacademy.Launcher.main(Launcher.java:XX)","title":"Cas d'exception"},{"location":"java/functional_programming/#axe-damelioration","text":"On peut cr\u00e9er une classe utilitaire avec plein de m\u00e9thode statique pour les pr\u00e9dicats tel que checkEmail . Ceci permettrait de cr\u00e9er du code r\u00e9utilisable facilement. Si vous examinez attentivement la classe Validator<T> vous constaterez que les fonctions ne sont pas pures. a votre avis comment corriger cela ? Note Malgr\u00e9 le passage par r\u00e9f\u00e9rence et l'application partielle, le compilateur est en mesure de r\u00e9soudre le typage statique de Java par inf\u00e9rence. Pas de probl\u00e8me de ce c\u00f4t\u00e9-l\u00e0.","title":"Axe d'am\u00e9lioration"},{"location":"java/genericity/","text":"G\u00e9n\u00e9ricit\u00e9 Introduction La g\u00e9n\u00e9ricit\u00e9 est un concept de la programmation orient\u00e9e objet qui permet d'appliquer des comportements communs mais \u00e0 des objets de natures diff\u00e9rentes. Caract\u00e9ristiques du langage Java : La mise en \u0153uvre de la g\u00e9n\u00e9ricit\u00e9 en Java s'appuie sur la notation en diamant qui prend en param\u00e8tre le nom d'une classe: <MyType> . Usage Basique Le cas le plus courant de l'usage basique de la g\u00e9n\u00e9ricit\u00e9 est rencontr\u00e9e avec les collections et les dictionnaires en Java. Exemple : // Cr\u00e9ation d'une liste simple ne pouvant contenir uniquement des objets de type 'java.lang.String'. ArrayList<String> list = new ArrayList<String>(); Inf\u00e9rence de type : // Depuis Java 1.7 on peut laisser le diamant vide lors de l'instanciation. // La g\u00e9n\u00e9ricit\u00e9 est port\u00e9e par la d\u00e9claration de la variable. ArrayList<String> list = new ArrayList<>(); // Fonctionne sans probl\u00e8me avec le polymorphisme. List<String> list = new ArrayList<>(); // En Java 10, la g\u00e9n\u00e9ricit\u00e9 doit \u00eatre port\u00e9 par le membre de droite avec le mot-clef 'var'. var list = new ArrayList<String>(); var emptyList = List.of(); // Quel est le type g\u00e9n\u00e9rique de cette liste ??? // Dans de rare cas, il peut \u00eatre n\u00e9cessaire de forcer l'inf\u00e9rence. // Sinon le compilateur utilisera 'java.lang.Object' par d\u00e9faut. var list = List.<String>of(); // Autre exemple var otherList = Collections.<String>emptyList(); var list = new ArrayList<String>(); var message = \"Hello World\"; list.add(message); ^^^^^^^--------// La variable 'message' est de type 'java.lang.String' // L'objet peut \u00eatre ins\u00e9r\u00e9 dans la liste var code = 42; list.add(code); ^^^^^----------// Erreur de compilation ! // La variable 'code' n'est pas de type 'java.lang.String' Note La g\u00e9n\u00e9ricit\u00e9 assure le typage statique de Java. Elle permet de factoriser du comportement. Mise en \u0153uvre Vous pouvez construire vos propres codes g\u00e9n\u00e9riques \u00e0 partir de classes abstraites ou des interfaces . La d\u00e9claration de la g\u00e9n\u00e9ricit\u00e9 se fait dans la signature de la classe. public interface Repository<E> { /* ... */ } public abstract class AbstractDAO<E>{ /* ... */ } Il est possible de placer autant de type g\u00e9n\u00e9rique que n\u00e9cessaire: public interface Repository<A, B, C, D, E> { /* ... */ } Dans ces exemples de code ci-dessus, la g\u00e9n\u00e9ricit\u00e9 ne contient pas de nom de classe. En effet \u00e0 ce stade, il s'agit de type abstrait. C'est \u00e0 dire, dans la hi\u00e9rarchie descendante des classes employant la g\u00e9n\u00e9ricit\u00e9, il existe une classe qui r\u00e9sout cette g\u00e9n\u00e9ricit\u00e9 par un type concret. // Le type 'E' est un type g\u00e9n\u00e9rique, il ne correspond \u00e0 aucune classe Java. public interface DAO<E> { /* ... */ } // Classe r\u00e9elle public class Customer{ /* ... */ } // Cette classe enfant, r\u00e9sout la g\u00e9n\u00e9ricit\u00e9 en rempla\u00e7ant 'E' par un type r\u00e9el: 'Customer'. public class CustomerDAO implements DAO<Customer>{ /* ... */ } Convention de nommage En Java le type g\u00e9n\u00e9rique abstrait doit \u00eatre une lettre en majuscule . Cette lettre n'est pas choisi au hasard, elle poss\u00e8de une signification. Exemples: T => Type : Type quelconque A => Any : Type quelconque X => Unknow : Type inconnu E => Element : Type d'\u00e9l\u00e9ment, ou d'entit\u00e9 K => Key : Type clef (pour les dictionnaires par exemple) V => Value : Type valeur (pour les dictionnaires par exemple) R => Result : Type de r\u00e9sultat, ou de retour I => Identifier : Type d'identifiant S => Source : Type source (pour des convertisseurs par exemple) D => Destination : Type destination (pour des convertisseurs par exemple) \u00c0 vous de d\u00e9cliner suivant le sens \u00e0 donner dans votre architecture. Comportement Consid\u00e9rons le code suivant : public abstract class AbstractDAO<E> { // ... public void save(E entity){ // ... } } public class CustomerDAO extends AbstractDAO<Customer>{ // ... @Override public void save(Customer entity){ // ... } } Point de vue de classe abstraite AbstractDAO : La m\u00e9thode save prend en param\u00e8tre un objet de type E . A ce stade le type E est abstrait, les seules m\u00e9thodes visibles par l'objet entity sont ceux de la classe java.lang.Object . En effet toutes classes h\u00e9ritent de cette derni\u00e8re. Le type E est un type g\u00e9n\u00e9rique dont la port\u00e9e est l'instance de cette classe : les m\u00e9thodes peuvent utiliser E comme type de param\u00e8tre, ou type de retour, les attributs peuvent \u00eatre typ\u00e9s E . En revanche E n'est pas utilisable pour les m\u00e9thodes et attributs statiques . Point de vue de classe abstraite CustomerDAO : Dans cette classe la g\u00e9n\u00e9ricit\u00e9 est r\u00e9solue, la m\u00e9thode save prend en param\u00e8tre un objet de type Customer . Toutes les m\u00e9thodes de ce dernier sont visibles. G\u00e9n\u00e9ricit\u00e9 au niveau d'une m\u00e9thode Commun\u00e9ment la g\u00e9n\u00e9ricit\u00e9 se d\u00e9clare au niveau de la classe. Mais il est possible de r\u00e9duire cette port\u00e9e au niveau d'une m\u00e9thode. La notation en diamant est donc port\u00e9e par la m\u00e9thode: public <T> T merge(T primary, T secondary){ // ... return (T) result; } Note Fonctionne aussi pour des m\u00e9thodes statiques . Soyez prudent avec les m\u00e9thodes g\u00e9n\u00e9riques, dans certains cas le typage n'est r\u00e9solu qu'a l'ex\u00e9cution ! Vous aurez dans ce cas une erreur de type java.lang.ClassCastException . Limitation La g\u00e9n\u00e9ricit\u00e9 ne peut pas s'appliquer aux types primitifs ! Utiliser l'\u00e9quivalent objet ! Type: boolean => Boolean byte => Byte short => Short int => Integer long => Long float => Float double => Double void => Void Pseudo-typage d'un type g\u00e9n\u00e9rique Probl\u00e9matique : public abstract class AbstractDAO<E>{ /* ... */ } Un g\u00e9n\u00e9rique est per\u00e7u par la classe abstraite ou l'interface comme un type java.lang.Object . Comment changer cette perception de la JVM pour coder plus efficacement sans utiliser le transtypage ? En effet, une classe qui h\u00e9rite de AbstractDAO peut remplacer E par n'importe quelle classe, ce qui peut casser la coh\u00e9rence de l'architecture du programme. Remplacer le type g\u00e9n\u00e9rique par une interface ou une classe n'est pas la solution car cela bloquerait la r\u00e9solution de la g\u00e9n\u00e9ricit\u00e9 dans les classes concr\u00e8tes. Mais l'id\u00e9e est l\u00e0. On souhaite restreinte le choix de E par une famille de classe. Pseudo-typage simple public interface Entity{ /* ... */ } public abstract class AbstractDAO<E extends Entity>{ /* ... */ } Dans l'exemple ci-dessus, le g\u00e9n\u00e9rique E est pseudo-typ\u00e9 par Entity . Cela signifie que E pour \u00eatre remplac\u00e9 dans les classes enfants par n'importe quelle classe qui h\u00e9rite de Entity . Note Pour \u00eatre pr\u00e9cis, <X extends Y> comprend tous les sous-types de Y OU le type Y lui-m\u00eame. Impl\u00e9mentation : public class Customer implements Entity{ /* ... */ } public class CustomerDAO extends AbstractDAO<Customer> { /* ... */ } ^^^^^^^^----------------// OK: Typage conforme. // La classe 'Customer' est bien // un sous-type de 'Entity'. public class FakeDAO extends AbstractDAO<String> { /* ... */ } ^^^^^^----------------------// KO: Erreur de compilation ! // La classe 'java.lang.String' // n'est pas un sous-type de 'Entity'. Pseudo-typage multiple Le pseudo-typage Java nous permet m\u00eame d'\u00eatre plus pr\u00e9cis en prenant en compte l'h\u00e9ritage multiple. public abstract class AbstractDAO<E extends Entity & Serializable>{ /* ... */ } La notation en diamant, <E extends Entity & Serializable> , nous indique que E doit \u00eatre un sous type qui h\u00e9rite de Entity ET de java.io.Serializable . Impl\u00e9mentation : public class Customer implements Entity, Serializable{ /* ... */ } public classe CustomerDAO extends AbstractDAO<Customer> { /* ... */ } ^^^^^^^^---------------// OK: Typage conforme. // La classe 'Customer' est bien // un sous-type de 'Entity' // ET 'java.io.Serializable'. public class Fake implements Entity{ /* ... */ } public classe FakeDAO extends AbstractDAO<Fake> { /* ... */ } ^^^^------------------// KO: Erreur de compilation ! // La classe 'Fake' est bien // un sous-type de 'Entity' // MAIS PAS DE 'java.io.Serializable'. G\u00e9n\u00e9ricit\u00e9 en profondeur Il est possible que le pseudo-typage d'un g\u00e9n\u00e9rique soit compos\u00e9 d'une classe utilisant elle-m\u00eame la g\u00e9n\u00e9ricit\u00e9 (qui elle-m\u00eame \u00e0 son tour soit compos\u00e9e de g\u00e9n\u00e9riques). Pour une coh\u00e9rence maximale du code, il faut que les types g\u00e9n\u00e9riques soit d\u00e9clar\u00e9s dans les classes abstraites ou les interfaces, puis r\u00e9solu dans les classes enfants. Exemple : // Le type 'K' d\u00e9signe le type g\u00e9n\u00e9rique d'un identifiant unique pour une entit\u00e9. public interface Entity<K>{ K getId(); } // Notation en diamant contenant elle-m\u00eame une autre notation en diamant. // C'est la g\u00e9n\u00e9ricit\u00e9 en profondeur. // Pour exploiter le g\u00e9n\u00e9rique 'K', il faut le d\u00e9clarer au m\u00eame niveau que 'E'. // Ainsi cette classe poss\u00e8de deux g\u00e9n\u00e9riques. public abstract class AbstractDAO<E extends Entity<K>, K> { // ... // Sauvegarder une entit\u00e9. public void save(E entity){ /* ... */ } // Rechercher une entit\u00e9 en fonction de son identifiant. // Gr\u00e2ce \u00e0 la g\u00e9n\u00e9ricit\u00e9 en profondeur, le typage est coh\u00e9rent. public E findById(K id){ /* ... */ } } Note Il est important de r\u00e9soudre la g\u00e9n\u00e9ricit\u00e9 en profondeur. En l'absence de cette d\u00e9claration, Java consid\u00e8rera le g\u00e9n\u00e9rique manquant de type java.lang.Object . Ce qui peut amener \u00e0 faire du transtypage , une pratique \u00e0 \u00e9viter. Avec pseudo-typage: // Le type 'K' d\u00e9signe le type g\u00e9n\u00e9rique d'un identifiant unique pour une entit\u00e9. // De plus 'K' doit \u00eatre d'un sous-type de 'java.io.Serializable'. public interface Entity<K extends Serializable>{ K getId(); } // Exemple de classe d'entit\u00e9 // Comme cette classe est s\u00e9rialisable, imposer le pseudo-typage de 'K' est donc logique. public class Customer implements Entity<UUID>, Comparable<Customer>, Serializable{ private UUID id; private String familyName; private String givenName; // ... // Typage par r\u00e9solution de la g\u00e9n\u00e9ricit\u00e9. @Override public int compareTo(Customer other) { return Comparator .comparing(Customer::getFamilyName) .comparing(Customer::getGivenName) .compare(this, other); } // Typage par r\u00e9solution de la g\u00e9n\u00e9ricit\u00e9. @Override public UUID getId(){ return id; } // Accesseurs & Mutateurs // ... } // G\u00e9n\u00e9ricit\u00e9 en profondeur avec pseudo-typage. public class AbstractDAO<E extends Entity<K> & Comparable<E> & Serializable, K extends Serializable>{ // ... } Comme on peut le voir la syntaxe devient de plus en plus complexe. La notation en diamant <E extends Entity<K> & Comparable<E> & Serializable, K extends Serializable> impose : Le type E doit \u00eatre un sous-type de Entity ET java.lang.Comparable ET java.io.Serializable . Le pseudo-typage java.lang.Comparable doit se faire avec le type E Le type K doit \u00eatre un sous-type de java.io.Serializable. Caract\u00e8re joker Il arrive que dans certains cas la r\u00e9solution de la g\u00e9n\u00e9ricit\u00e9 en profondeur n'apporte aucune plus-value dans les classes abstraites ou les interfaces. Dans ce cas, plut\u00f4t que d\u2019omettre la g\u00e9n\u00e9ricit\u00e9 en profondeur, on utilise le caract\u00e8re ? aussi connu sous le nom de //wildcard// . Exemple : public interface Entity<K>{ /* ... */ } public abstract class AbstractDAO<E extends Entity<?>> { /* ... */ } Dans cette d\u00e9claration <E extends Entity<?> > , E doit \u00eatre un sous-type de Entity . En revanche, on ne se soucie pas du type g\u00e9n\u00e9rique port\u00e9 par Entity . Note M\u00eame si ? se per\u00e7oit comme java.lang.Object , en r\u00e9alit\u00e9, il faut le consid\u00e9rer comme un type quelconque. Lors de l'usage d'un <?> dans la g\u00e9n\u00e9ricit\u00e9, le d\u00e9veloppeur doit s'engager \u00e0 ne pas faire r\u00e9f\u00e9rence \u00e0 ce g\u00e9n\u00e9rique. Exemple : List<?> anyList = new ArrayList<>(); ^^^---------// OK: Tout \u00e0 fait possible d'instancier cette liste de type '?'. // (Mais cela n'a pas int\u00e9r\u00eat en r\u00e9alit\u00e9) anyList.add(\"Hello World\"); ^^^^^^^^^^^^^---------// KO: Erreur de compilation ! // La m\u00e9thode 'add' prend en param\u00e8tre un type '?'. // Ce param\u00e8tre est donc invalide. anyList.add(null); ^^^^------------------// OK: 'null' n'a pas de type. // Ce param\u00e8tre est donc valide. // (Tr\u00e8s moche en r\u00e9alit\u00e9) List<?> anyList = List.of(\"Hello World\"); ^^^---------// OK: Tout \u00e0 fait possible d'instancier cette liste de type '?'. var item = anyList.get(0); ^^^---------// OK: Appel autoris\u00e9 // La m\u00e9thode 'get' ne fait pas r\u00e9f\u00e9rence au type '?' dans sa signature. // En revanche elle retourne un objet de type '?'. // Par polymorphisme Java va typer 'item' en 'java.lang.Object'. var text = (String) anyList.get(0); ^^^^^^-----------// OK: Transtypage valide // On peut r\u00e9cup\u00e9rer le type r\u00e9el de l'objet contenu dans la liste. Note Soyez prudent lors d'un transtypage ! Le compilateur ne peut pas v\u00e9rifier le typage pour vous ! Conclusion : L'emploi du joker ? dans la d\u00e9claration des g\u00e9n\u00e9riques peut all\u00e9ger son \u00e9criture si le d\u00e9veloppeur s'engage \u00e0 ne pas faire r\u00e9f\u00e9rence \u00e0 ce type ? . Si dans votre code vous \u00eates amen\u00e9 \u00e0 faire du transtypage partout \u00e0 cause du ? c'est que ce n'est pas la bonne approche ! La g\u00e9n\u00e9ricit\u00e9 en Java est apparue en version 1.5 pour justement \u00e9viter le transtypage abusif. L'usage du transtypage n'est pas prohib\u00e9 en soit, il doit servir dans un p\u00e9rim\u00e8tre restreint. Java reste un langage \u00e0 typage statique !","title":"G\u00e9n\u00e9ricit\u00e9"},{"location":"java/genericity/#genericite","text":"","title":"G\u00e9n\u00e9ricit\u00e9"},{"location":"java/genericity/#introduction","text":"La g\u00e9n\u00e9ricit\u00e9 est un concept de la programmation orient\u00e9e objet qui permet d'appliquer des comportements communs mais \u00e0 des objets de natures diff\u00e9rentes. Caract\u00e9ristiques du langage Java : La mise en \u0153uvre de la g\u00e9n\u00e9ricit\u00e9 en Java s'appuie sur la notation en diamant qui prend en param\u00e8tre le nom d'une classe: <MyType> .","title":"Introduction"},{"location":"java/genericity/#usage-basique","text":"Le cas le plus courant de l'usage basique de la g\u00e9n\u00e9ricit\u00e9 est rencontr\u00e9e avec les collections et les dictionnaires en Java. Exemple : // Cr\u00e9ation d'une liste simple ne pouvant contenir uniquement des objets de type 'java.lang.String'. ArrayList<String> list = new ArrayList<String>(); Inf\u00e9rence de type : // Depuis Java 1.7 on peut laisser le diamant vide lors de l'instanciation. // La g\u00e9n\u00e9ricit\u00e9 est port\u00e9e par la d\u00e9claration de la variable. ArrayList<String> list = new ArrayList<>(); // Fonctionne sans probl\u00e8me avec le polymorphisme. List<String> list = new ArrayList<>(); // En Java 10, la g\u00e9n\u00e9ricit\u00e9 doit \u00eatre port\u00e9 par le membre de droite avec le mot-clef 'var'. var list = new ArrayList<String>(); var emptyList = List.of(); // Quel est le type g\u00e9n\u00e9rique de cette liste ??? // Dans de rare cas, il peut \u00eatre n\u00e9cessaire de forcer l'inf\u00e9rence. // Sinon le compilateur utilisera 'java.lang.Object' par d\u00e9faut. var list = List.<String>of(); // Autre exemple var otherList = Collections.<String>emptyList(); var list = new ArrayList<String>(); var message = \"Hello World\"; list.add(message); ^^^^^^^--------// La variable 'message' est de type 'java.lang.String' // L'objet peut \u00eatre ins\u00e9r\u00e9 dans la liste var code = 42; list.add(code); ^^^^^----------// Erreur de compilation ! // La variable 'code' n'est pas de type 'java.lang.String' Note La g\u00e9n\u00e9ricit\u00e9 assure le typage statique de Java. Elle permet de factoriser du comportement.","title":"Usage Basique"},{"location":"java/genericity/#mise-en-uvre","text":"Vous pouvez construire vos propres codes g\u00e9n\u00e9riques \u00e0 partir de classes abstraites ou des interfaces . La d\u00e9claration de la g\u00e9n\u00e9ricit\u00e9 se fait dans la signature de la classe. public interface Repository<E> { /* ... */ } public abstract class AbstractDAO<E>{ /* ... */ } Il est possible de placer autant de type g\u00e9n\u00e9rique que n\u00e9cessaire: public interface Repository<A, B, C, D, E> { /* ... */ } Dans ces exemples de code ci-dessus, la g\u00e9n\u00e9ricit\u00e9 ne contient pas de nom de classe. En effet \u00e0 ce stade, il s'agit de type abstrait. C'est \u00e0 dire, dans la hi\u00e9rarchie descendante des classes employant la g\u00e9n\u00e9ricit\u00e9, il existe une classe qui r\u00e9sout cette g\u00e9n\u00e9ricit\u00e9 par un type concret. // Le type 'E' est un type g\u00e9n\u00e9rique, il ne correspond \u00e0 aucune classe Java. public interface DAO<E> { /* ... */ } // Classe r\u00e9elle public class Customer{ /* ... */ } // Cette classe enfant, r\u00e9sout la g\u00e9n\u00e9ricit\u00e9 en rempla\u00e7ant 'E' par un type r\u00e9el: 'Customer'. public class CustomerDAO implements DAO<Customer>{ /* ... */ }","title":"Mise en \u0153uvre"},{"location":"java/genericity/#convention-de-nommage","text":"En Java le type g\u00e9n\u00e9rique abstrait doit \u00eatre une lettre en majuscule . Cette lettre n'est pas choisi au hasard, elle poss\u00e8de une signification. Exemples: T => Type : Type quelconque A => Any : Type quelconque X => Unknow : Type inconnu E => Element : Type d'\u00e9l\u00e9ment, ou d'entit\u00e9 K => Key : Type clef (pour les dictionnaires par exemple) V => Value : Type valeur (pour les dictionnaires par exemple) R => Result : Type de r\u00e9sultat, ou de retour I => Identifier : Type d'identifiant S => Source : Type source (pour des convertisseurs par exemple) D => Destination : Type destination (pour des convertisseurs par exemple) \u00c0 vous de d\u00e9cliner suivant le sens \u00e0 donner dans votre architecture.","title":"Convention de nommage"},{"location":"java/genericity/#comportement","text":"Consid\u00e9rons le code suivant : public abstract class AbstractDAO<E> { // ... public void save(E entity){ // ... } } public class CustomerDAO extends AbstractDAO<Customer>{ // ... @Override public void save(Customer entity){ // ... } } Point de vue de classe abstraite AbstractDAO : La m\u00e9thode save prend en param\u00e8tre un objet de type E . A ce stade le type E est abstrait, les seules m\u00e9thodes visibles par l'objet entity sont ceux de la classe java.lang.Object . En effet toutes classes h\u00e9ritent de cette derni\u00e8re. Le type E est un type g\u00e9n\u00e9rique dont la port\u00e9e est l'instance de cette classe : les m\u00e9thodes peuvent utiliser E comme type de param\u00e8tre, ou type de retour, les attributs peuvent \u00eatre typ\u00e9s E . En revanche E n'est pas utilisable pour les m\u00e9thodes et attributs statiques . Point de vue de classe abstraite CustomerDAO : Dans cette classe la g\u00e9n\u00e9ricit\u00e9 est r\u00e9solue, la m\u00e9thode save prend en param\u00e8tre un objet de type Customer . Toutes les m\u00e9thodes de ce dernier sont visibles.","title":"Comportement"},{"location":"java/genericity/#genericite-au-niveau-dune-methode","text":"Commun\u00e9ment la g\u00e9n\u00e9ricit\u00e9 se d\u00e9clare au niveau de la classe. Mais il est possible de r\u00e9duire cette port\u00e9e au niveau d'une m\u00e9thode. La notation en diamant est donc port\u00e9e par la m\u00e9thode: public <T> T merge(T primary, T secondary){ // ... return (T) result; } Note Fonctionne aussi pour des m\u00e9thodes statiques . Soyez prudent avec les m\u00e9thodes g\u00e9n\u00e9riques, dans certains cas le typage n'est r\u00e9solu qu'a l'ex\u00e9cution ! Vous aurez dans ce cas une erreur de type java.lang.ClassCastException .","title":"G\u00e9n\u00e9ricit\u00e9 au niveau d'une m\u00e9thode"},{"location":"java/genericity/#limitation","text":"La g\u00e9n\u00e9ricit\u00e9 ne peut pas s'appliquer aux types primitifs ! Utiliser l'\u00e9quivalent objet ! Type: boolean => Boolean byte => Byte short => Short int => Integer long => Long float => Float double => Double void => Void","title":"Limitation"},{"location":"java/genericity/#pseudo-typage-dun-type-generique","text":"Probl\u00e9matique : public abstract class AbstractDAO<E>{ /* ... */ } Un g\u00e9n\u00e9rique est per\u00e7u par la classe abstraite ou l'interface comme un type java.lang.Object . Comment changer cette perception de la JVM pour coder plus efficacement sans utiliser le transtypage ? En effet, une classe qui h\u00e9rite de AbstractDAO peut remplacer E par n'importe quelle classe, ce qui peut casser la coh\u00e9rence de l'architecture du programme. Remplacer le type g\u00e9n\u00e9rique par une interface ou une classe n'est pas la solution car cela bloquerait la r\u00e9solution de la g\u00e9n\u00e9ricit\u00e9 dans les classes concr\u00e8tes. Mais l'id\u00e9e est l\u00e0. On souhaite restreinte le choix de E par une famille de classe.","title":"Pseudo-typage d'un type g\u00e9n\u00e9rique"},{"location":"java/genericity/#pseudo-typage-simple","text":"public interface Entity{ /* ... */ } public abstract class AbstractDAO<E extends Entity>{ /* ... */ } Dans l'exemple ci-dessus, le g\u00e9n\u00e9rique E est pseudo-typ\u00e9 par Entity . Cela signifie que E pour \u00eatre remplac\u00e9 dans les classes enfants par n'importe quelle classe qui h\u00e9rite de Entity . Note Pour \u00eatre pr\u00e9cis, <X extends Y> comprend tous les sous-types de Y OU le type Y lui-m\u00eame. Impl\u00e9mentation : public class Customer implements Entity{ /* ... */ } public class CustomerDAO extends AbstractDAO<Customer> { /* ... */ } ^^^^^^^^----------------// OK: Typage conforme. // La classe 'Customer' est bien // un sous-type de 'Entity'. public class FakeDAO extends AbstractDAO<String> { /* ... */ } ^^^^^^----------------------// KO: Erreur de compilation ! // La classe 'java.lang.String' // n'est pas un sous-type de 'Entity'.","title":"Pseudo-typage simple"},{"location":"java/genericity/#pseudo-typage-multiple","text":"Le pseudo-typage Java nous permet m\u00eame d'\u00eatre plus pr\u00e9cis en prenant en compte l'h\u00e9ritage multiple. public abstract class AbstractDAO<E extends Entity & Serializable>{ /* ... */ } La notation en diamant, <E extends Entity & Serializable> , nous indique que E doit \u00eatre un sous type qui h\u00e9rite de Entity ET de java.io.Serializable . Impl\u00e9mentation : public class Customer implements Entity, Serializable{ /* ... */ } public classe CustomerDAO extends AbstractDAO<Customer> { /* ... */ } ^^^^^^^^---------------// OK: Typage conforme. // La classe 'Customer' est bien // un sous-type de 'Entity' // ET 'java.io.Serializable'. public class Fake implements Entity{ /* ... */ } public classe FakeDAO extends AbstractDAO<Fake> { /* ... */ } ^^^^------------------// KO: Erreur de compilation ! // La classe 'Fake' est bien // un sous-type de 'Entity' // MAIS PAS DE 'java.io.Serializable'.","title":"Pseudo-typage multiple"},{"location":"java/genericity/#genericite-en-profondeur","text":"Il est possible que le pseudo-typage d'un g\u00e9n\u00e9rique soit compos\u00e9 d'une classe utilisant elle-m\u00eame la g\u00e9n\u00e9ricit\u00e9 (qui elle-m\u00eame \u00e0 son tour soit compos\u00e9e de g\u00e9n\u00e9riques). Pour une coh\u00e9rence maximale du code, il faut que les types g\u00e9n\u00e9riques soit d\u00e9clar\u00e9s dans les classes abstraites ou les interfaces, puis r\u00e9solu dans les classes enfants. Exemple : // Le type 'K' d\u00e9signe le type g\u00e9n\u00e9rique d'un identifiant unique pour une entit\u00e9. public interface Entity<K>{ K getId(); } // Notation en diamant contenant elle-m\u00eame une autre notation en diamant. // C'est la g\u00e9n\u00e9ricit\u00e9 en profondeur. // Pour exploiter le g\u00e9n\u00e9rique 'K', il faut le d\u00e9clarer au m\u00eame niveau que 'E'. // Ainsi cette classe poss\u00e8de deux g\u00e9n\u00e9riques. public abstract class AbstractDAO<E extends Entity<K>, K> { // ... // Sauvegarder une entit\u00e9. public void save(E entity){ /* ... */ } // Rechercher une entit\u00e9 en fonction de son identifiant. // Gr\u00e2ce \u00e0 la g\u00e9n\u00e9ricit\u00e9 en profondeur, le typage est coh\u00e9rent. public E findById(K id){ /* ... */ } } Note Il est important de r\u00e9soudre la g\u00e9n\u00e9ricit\u00e9 en profondeur. En l'absence de cette d\u00e9claration, Java consid\u00e8rera le g\u00e9n\u00e9rique manquant de type java.lang.Object . Ce qui peut amener \u00e0 faire du transtypage , une pratique \u00e0 \u00e9viter. Avec pseudo-typage: // Le type 'K' d\u00e9signe le type g\u00e9n\u00e9rique d'un identifiant unique pour une entit\u00e9. // De plus 'K' doit \u00eatre d'un sous-type de 'java.io.Serializable'. public interface Entity<K extends Serializable>{ K getId(); } // Exemple de classe d'entit\u00e9 // Comme cette classe est s\u00e9rialisable, imposer le pseudo-typage de 'K' est donc logique. public class Customer implements Entity<UUID>, Comparable<Customer>, Serializable{ private UUID id; private String familyName; private String givenName; // ... // Typage par r\u00e9solution de la g\u00e9n\u00e9ricit\u00e9. @Override public int compareTo(Customer other) { return Comparator .comparing(Customer::getFamilyName) .comparing(Customer::getGivenName) .compare(this, other); } // Typage par r\u00e9solution de la g\u00e9n\u00e9ricit\u00e9. @Override public UUID getId(){ return id; } // Accesseurs & Mutateurs // ... } // G\u00e9n\u00e9ricit\u00e9 en profondeur avec pseudo-typage. public class AbstractDAO<E extends Entity<K> & Comparable<E> & Serializable, K extends Serializable>{ // ... } Comme on peut le voir la syntaxe devient de plus en plus complexe. La notation en diamant <E extends Entity<K> & Comparable<E> & Serializable, K extends Serializable> impose : Le type E doit \u00eatre un sous-type de Entity ET java.lang.Comparable ET java.io.Serializable . Le pseudo-typage java.lang.Comparable doit se faire avec le type E Le type K doit \u00eatre un sous-type de java.io.Serializable.","title":"G\u00e9n\u00e9ricit\u00e9 en profondeur"},{"location":"java/genericity/#caractere-joker","text":"Il arrive que dans certains cas la r\u00e9solution de la g\u00e9n\u00e9ricit\u00e9 en profondeur n'apporte aucune plus-value dans les classes abstraites ou les interfaces. Dans ce cas, plut\u00f4t que d\u2019omettre la g\u00e9n\u00e9ricit\u00e9 en profondeur, on utilise le caract\u00e8re ? aussi connu sous le nom de //wildcard// . Exemple : public interface Entity<K>{ /* ... */ } public abstract class AbstractDAO<E extends Entity<?>> { /* ... */ } Dans cette d\u00e9claration <E extends Entity<?> > , E doit \u00eatre un sous-type de Entity . En revanche, on ne se soucie pas du type g\u00e9n\u00e9rique port\u00e9 par Entity . Note M\u00eame si ? se per\u00e7oit comme java.lang.Object , en r\u00e9alit\u00e9, il faut le consid\u00e9rer comme un type quelconque. Lors de l'usage d'un <?> dans la g\u00e9n\u00e9ricit\u00e9, le d\u00e9veloppeur doit s'engager \u00e0 ne pas faire r\u00e9f\u00e9rence \u00e0 ce g\u00e9n\u00e9rique. Exemple : List<?> anyList = new ArrayList<>(); ^^^---------// OK: Tout \u00e0 fait possible d'instancier cette liste de type '?'. // (Mais cela n'a pas int\u00e9r\u00eat en r\u00e9alit\u00e9) anyList.add(\"Hello World\"); ^^^^^^^^^^^^^---------// KO: Erreur de compilation ! // La m\u00e9thode 'add' prend en param\u00e8tre un type '?'. // Ce param\u00e8tre est donc invalide. anyList.add(null); ^^^^------------------// OK: 'null' n'a pas de type. // Ce param\u00e8tre est donc valide. // (Tr\u00e8s moche en r\u00e9alit\u00e9) List<?> anyList = List.of(\"Hello World\"); ^^^---------// OK: Tout \u00e0 fait possible d'instancier cette liste de type '?'. var item = anyList.get(0); ^^^---------// OK: Appel autoris\u00e9 // La m\u00e9thode 'get' ne fait pas r\u00e9f\u00e9rence au type '?' dans sa signature. // En revanche elle retourne un objet de type '?'. // Par polymorphisme Java va typer 'item' en 'java.lang.Object'. var text = (String) anyList.get(0); ^^^^^^-----------// OK: Transtypage valide // On peut r\u00e9cup\u00e9rer le type r\u00e9el de l'objet contenu dans la liste. Note Soyez prudent lors d'un transtypage ! Le compilateur ne peut pas v\u00e9rifier le typage pour vous ! Conclusion : L'emploi du joker ? dans la d\u00e9claration des g\u00e9n\u00e9riques peut all\u00e9ger son \u00e9criture si le d\u00e9veloppeur s'engage \u00e0 ne pas faire r\u00e9f\u00e9rence \u00e0 ce type ? . Si dans votre code vous \u00eates amen\u00e9 \u00e0 faire du transtypage partout \u00e0 cause du ? c'est que ce n'est pas la bonne approche ! La g\u00e9n\u00e9ricit\u00e9 en Java est apparue en version 1.5 pour justement \u00e9viter le transtypage abusif. L'usage du transtypage n'est pas prohib\u00e9 en soit, il doit servir dans un p\u00e9rim\u00e8tre restreint. Java reste un langage \u00e0 typage statique !","title":"Caract\u00e8re joker"},{"location":"java/inheritance/","text":"H\u00e9ritage Introduction L'h\u00e9ritage est un concept de la programmation orient\u00e9e objet . Il permet de : D\u00e9terminer une hi\u00e9rarchie dans les classes et les regrouper par familles. Factoriser des comportements et des caract\u00e9ristiques communes. Red\u00e9finir des comportements. Caract\u00e9ristiques du langage Java : Toutes classes Java h\u00e9rite de java.lang.Object . Une classe concr\u00e8te ou abstraite ne peut h\u00e9riter que d'une seule classe concr\u00e8te ou abstraite . Une classe concr\u00e8te ou abstraite peut h\u00e9riter de plusieurs interfaces . Une interface peut h\u00e9riter de plusieurs interfaces . Une \u00e9num\u00e9ration ne peut pas \u00eatre h\u00e9rit\u00e9e, ou h\u00e9riter de classes, mais il peut impl\u00e9menter des interfaces . Une annotation ne supporte pas l'h\u00e9ritage, mais bizarrement peut \u00eatre h\u00e9rit\u00e9e. Mise en \u0153uvre Quelques mots clef sont \u00e0 connaitre pour utiliser l'h\u00e9ritage en Java: protected : Niveau de visibilit\u00e9 prot\u00e9g\u00e9, visible par les classes enfants et classe du m\u00eame package . extends : Dans la d\u00e9claration d'une classe, permet de sp\u00e9cifier la classe \u00e0 h\u00e9riter. implements : Dans la d\u00e9claration d'une classe, permet de sp\u00e9cifier les interfaces \u00e0 h\u00e9riter. final : Dans la d\u00e9claration d'une classe, bloque l'h\u00e9ritage de cette derni\u00e8re (pas de classes enfants possibles). Dans la d\u00e9claration d'une m\u00e9thode, bloque la red\u00e9finition de m\u00e9thode pour les classes enfants. Point particulier H\u00e9ritage pour une classe : public abstract class AbstractEntity { /* ... */ } public class Cutomer extends AbstractEntity implements Serializable, Comparable<Customer> { /* ... */ } H\u00e9ritage pour une interface : public interface Repository<E> { /* ... */ } public interface CustomerRepository extends Serializable, Repository<Customer> { /* ... */ } Cas d'usage Consid\u00e9rons les classes suivantes: package fr.zelmoacademy.sample; import java.time.LocalDate; public class Cat { private String name; private Float size; private Float weight; private LocalDate birthDate; public Cat() { } public void talk() { System.out.println(\"Meow\"); } public void sleep() { System.out.println(\"Purrr\"); } public void huntMice() { // ... } // Accesseurs & Mutateurs // ... } package fr.zelmoacademy.sample; import java.time.LocalDate; public class Dog { private String name; private Float size; private Float weight; private LocalDate birthDate; public Dog() { } public void talk() { System.out.println(\"Woof\"); } public void sleep() { System.out.println(\"Zzz\"); } public void sniff() { // ... } // Accesseurs & Mutateurs // ... } Cet exemple caricatural met en \u00e9vidence des caract\u00e9ristiques communes entre les deux classes. On peut donc factoriser du code dans une classe abstraite : package fr.zelmoacademy.sample; import java.time.LocalDate; import java.time.Period; // Mot clef 'abstract' pour indiquer que cette classe est abstraite // et donc ne peut pas \u00eatre instancier directement. public abstract class Pet { // Attributs \u00e0 visibilit\u00e9 'protected' // Visible par les classes enfants et les classes du m\u00eame 'package'. protected String name; protected Float size; protected Float weight; protected LocalDate birthDate; // Constructeur par d\u00e9faut // Visibilit\u00e9 'protected' recommand\u00e9e. protected Pet() { } // M\u00e9thode abstraite // Les classes enfants seront oblig\u00e9es de d\u00e9finir un comportement. public abstract void talk(); // M\u00e9thode concr\u00e8te // Les classes enfants peuvent red\u00e9finir un comportement. public void sleep() { System.out.println(\"...zzz...\"); } // Mot clef 'final'. // M\u00e9thode concr\u00e8te verrouill\u00e9e. // Les classes enfants ne peuvent pas la red\u00e9finir. public final Period getAge(){ return Period.between(LocalDate.now(), birthDate); } // Accesseurs & Mutateurs // ... } Nouvelles classes r\u00e9usin\u00e9es : package fr.zelmoacademy.sample; // Mot clef 'exetends' pour sp\u00e9cifier le nom de la classe parente. public class Cat extends Pet { public Cat() { } // Annotation 'Override' // Impl\u00e9mente le comportement sp\u00e9cifique \u00e0 cette classe. @Override public void talk() { System.out.println(\"Meow\"); } // Annotation 'Override' // Impl\u00e9mente le comportement sp\u00e9cifique \u00e0 cette classe. // Ne tient pas en compte le comportement de la classe parente. @Override public void sleep() { System.out.println(\"Purrr\"); } // M\u00e9thode sp\u00e9cifique \u00e0 cette classe. public void huntMice() { // ... } } package fr.zelmoacademy.sample; // Mot clef 'exetends' pour sp\u00e9cifier le nom de la classe parente. // Mot clef 'final', cette classe ne peut plus \u00eatre h\u00e9rit\u00e9e. public final class Dog extends Pet { public Dog() { } // Annotation 'Override' // Impl\u00e9mente le comportement sp\u00e9cifique \u00e0 cette classe. @Override public void talk() { System.out.println(\"Woof\"); } // Annotation 'Override' // Impl\u00e9mente le comportement sp\u00e9cifique \u00e0 cette classe. // Ne tient pas en compte le comportement de la classe parente. @Override public void sleep() { // Invocation de la m\u00e9thode parente, tel qu'elle a \u00e9t\u00e9 d\u00e9finit par cette derni\u00e8re. super.sleep(); // Impl\u00e9mentation sp\u00e9cifique de cette classe. System.out.println(\"Zzz\"); } // M\u00e9thode sp\u00e9cifique \u00e0 cette classe. public void sniff() { // ... } }","title":"H\u00e9ritage"},{"location":"java/inheritance/#heritage","text":"","title":"H\u00e9ritage"},{"location":"java/inheritance/#introduction","text":"L'h\u00e9ritage est un concept de la programmation orient\u00e9e objet . Il permet de : D\u00e9terminer une hi\u00e9rarchie dans les classes et les regrouper par familles. Factoriser des comportements et des caract\u00e9ristiques communes. Red\u00e9finir des comportements. Caract\u00e9ristiques du langage Java : Toutes classes Java h\u00e9rite de java.lang.Object . Une classe concr\u00e8te ou abstraite ne peut h\u00e9riter que d'une seule classe concr\u00e8te ou abstraite . Une classe concr\u00e8te ou abstraite peut h\u00e9riter de plusieurs interfaces . Une interface peut h\u00e9riter de plusieurs interfaces . Une \u00e9num\u00e9ration ne peut pas \u00eatre h\u00e9rit\u00e9e, ou h\u00e9riter de classes, mais il peut impl\u00e9menter des interfaces . Une annotation ne supporte pas l'h\u00e9ritage, mais bizarrement peut \u00eatre h\u00e9rit\u00e9e.","title":"Introduction"},{"location":"java/inheritance/#mise-en-uvre","text":"Quelques mots clef sont \u00e0 connaitre pour utiliser l'h\u00e9ritage en Java: protected : Niveau de visibilit\u00e9 prot\u00e9g\u00e9, visible par les classes enfants et classe du m\u00eame package . extends : Dans la d\u00e9claration d'une classe, permet de sp\u00e9cifier la classe \u00e0 h\u00e9riter. implements : Dans la d\u00e9claration d'une classe, permet de sp\u00e9cifier les interfaces \u00e0 h\u00e9riter. final : Dans la d\u00e9claration d'une classe, bloque l'h\u00e9ritage de cette derni\u00e8re (pas de classes enfants possibles). Dans la d\u00e9claration d'une m\u00e9thode, bloque la red\u00e9finition de m\u00e9thode pour les classes enfants.","title":"Mise en \u0153uvre"},{"location":"java/inheritance/#point-particulier","text":"H\u00e9ritage pour une classe : public abstract class AbstractEntity { /* ... */ } public class Cutomer extends AbstractEntity implements Serializable, Comparable<Customer> { /* ... */ } H\u00e9ritage pour une interface : public interface Repository<E> { /* ... */ } public interface CustomerRepository extends Serializable, Repository<Customer> { /* ... */ }","title":"Point particulier"},{"location":"java/inheritance/#cas-dusage","text":"Consid\u00e9rons les classes suivantes: package fr.zelmoacademy.sample; import java.time.LocalDate; public class Cat { private String name; private Float size; private Float weight; private LocalDate birthDate; public Cat() { } public void talk() { System.out.println(\"Meow\"); } public void sleep() { System.out.println(\"Purrr\"); } public void huntMice() { // ... } // Accesseurs & Mutateurs // ... } package fr.zelmoacademy.sample; import java.time.LocalDate; public class Dog { private String name; private Float size; private Float weight; private LocalDate birthDate; public Dog() { } public void talk() { System.out.println(\"Woof\"); } public void sleep() { System.out.println(\"Zzz\"); } public void sniff() { // ... } // Accesseurs & Mutateurs // ... } Cet exemple caricatural met en \u00e9vidence des caract\u00e9ristiques communes entre les deux classes. On peut donc factoriser du code dans une classe abstraite : package fr.zelmoacademy.sample; import java.time.LocalDate; import java.time.Period; // Mot clef 'abstract' pour indiquer que cette classe est abstraite // et donc ne peut pas \u00eatre instancier directement. public abstract class Pet { // Attributs \u00e0 visibilit\u00e9 'protected' // Visible par les classes enfants et les classes du m\u00eame 'package'. protected String name; protected Float size; protected Float weight; protected LocalDate birthDate; // Constructeur par d\u00e9faut // Visibilit\u00e9 'protected' recommand\u00e9e. protected Pet() { } // M\u00e9thode abstraite // Les classes enfants seront oblig\u00e9es de d\u00e9finir un comportement. public abstract void talk(); // M\u00e9thode concr\u00e8te // Les classes enfants peuvent red\u00e9finir un comportement. public void sleep() { System.out.println(\"...zzz...\"); } // Mot clef 'final'. // M\u00e9thode concr\u00e8te verrouill\u00e9e. // Les classes enfants ne peuvent pas la red\u00e9finir. public final Period getAge(){ return Period.between(LocalDate.now(), birthDate); } // Accesseurs & Mutateurs // ... } Nouvelles classes r\u00e9usin\u00e9es : package fr.zelmoacademy.sample; // Mot clef 'exetends' pour sp\u00e9cifier le nom de la classe parente. public class Cat extends Pet { public Cat() { } // Annotation 'Override' // Impl\u00e9mente le comportement sp\u00e9cifique \u00e0 cette classe. @Override public void talk() { System.out.println(\"Meow\"); } // Annotation 'Override' // Impl\u00e9mente le comportement sp\u00e9cifique \u00e0 cette classe. // Ne tient pas en compte le comportement de la classe parente. @Override public void sleep() { System.out.println(\"Purrr\"); } // M\u00e9thode sp\u00e9cifique \u00e0 cette classe. public void huntMice() { // ... } } package fr.zelmoacademy.sample; // Mot clef 'exetends' pour sp\u00e9cifier le nom de la classe parente. // Mot clef 'final', cette classe ne peut plus \u00eatre h\u00e9rit\u00e9e. public final class Dog extends Pet { public Dog() { } // Annotation 'Override' // Impl\u00e9mente le comportement sp\u00e9cifique \u00e0 cette classe. @Override public void talk() { System.out.println(\"Woof\"); } // Annotation 'Override' // Impl\u00e9mente le comportement sp\u00e9cifique \u00e0 cette classe. // Ne tient pas en compte le comportement de la classe parente. @Override public void sleep() { // Invocation de la m\u00e9thode parente, tel qu'elle a \u00e9t\u00e9 d\u00e9finit par cette derni\u00e8re. super.sleep(); // Impl\u00e9mentation sp\u00e9cifique de cette classe. System.out.println(\"Zzz\"); } // M\u00e9thode sp\u00e9cifique \u00e0 cette classe. public void sniff() { // ... } }","title":"Cas d'usage"},{"location":"java/invoke_dynamic/","text":"Invocation dynamique ` Introduction L'invocation dynamique est une technique avanc\u00e9e en Java pour appeler des m\u00e9thodes sans poss\u00e9der directement les objets concern\u00e9s. Avantages : * Code plus dynamique * Code plus g\u00e9n\u00e9rique Inconv\u00e9nient : * Concept complexe * Beaucoup plus verbeux Note Contrairement aux id\u00e9es re\u00e7ues, l'invocation dynamique en Java et m\u00eame plus rapide que l'appel classique de m\u00e9thodes (Quand elle respecte les r\u00e8gles de visibilit\u00e9s). La JVM sait optimiser ce code. En revanche l'invocation par r\u00e9flexion est \u00e0 \u00e9viter, elle est plus lente car la JVM ne peut optimiser ce code. Introspection L'introspection est une technique avanc\u00e9e en Java permettant de parcourir la composition de la structure m\u00eame d'un objet, ou d'une classe par le code. Usage basique package fr.zelmoacademy.model; public class Customer{ private String email; public Customer(){ } // Accesseurs & Mutateurs // ... } var customer = new Customer(); Field[] declaredFields = customer.getClass().getDeclaredFields(); ^^^^^^^^^^^^^^^^^-----// R\u00e9cup\u00e9ration de tous les attributs // d\u00e9clar\u00e9s dans la classe 'Customer'. System.out.println(Arrays.toString(declaredFields)); //> Sortie console: // [private java.lang.String fr.zelmoacademy.model.Customer.email] // On peut aussi faire l'instrospection de la classe directement // au lieu de passer par l'instance (*.getClass()). Method[] declaredMethods = Customer.class.getDeclaredMethods(); ^^^^^^^^^^^^^^^^^^-----// R\u00e9cup\u00e9ration de toutes les m\u00e9thodes // d\u00e9clar\u00e9s dans la classe 'Customer'. System.out.println(Arrays.toString(declaredMethods)); //> Sortie console: // [ // public void fr.zelmoacademy.model.Customer.setEmail(java.lang.String), // public java.lang.String fr.zelmoacademy.model.Customer.getEmail() // ] Type superClass = customer.getClass().getGenericSuperClass(); ^^^^^^^^^^^^^^^^^^^^^----// R\u00e9cup\u00e9rer la classe parent System.out.println(superClass); //> Sortie console: // class java.lang.Object Note Avec l'introspection vous pouvez naviguez dans la structure d'un classe est voir toutes ses caract\u00e9ristiques. cette approche permet en fonction de la structure d'un classe d'opter pour un comportement diff\u00e9rent dans votre algorithme. Usage avanc\u00e9 Probl\u00e9matique : public class Customer { /* ... */ } public abstract class AbstractDAO<E> { // ... // On ne connait pas 'E'. // On d\u00e9l\u00e8gue ce traitement aux classes enfants. // Cette m\u00e9thode est donc abstraite. protected abstract Class<E> getEntityClass(); } public class CustomerDAO extends AbstractDAO<Customer> { // ... @Override protected Class<Customer> getEntityClass(){ // La classe concr\u00e8te r\u00e9sout la g\u00e9n\u00e9ricit\u00e9 // Par cons\u00e9quant, elle connait le type de 'E' // Il suffit d'impl\u00e9menter la m\u00e9thode. return Customer.class; } } Dans le code ci-dessus, on souhaite r\u00e9cup\u00e9rer la classe de E . Pour se faire, une mani\u00e8re simple est de passer par l'h\u00e9ritage. Cette m\u00e9thode est viable, mais que ce passe-t-il lorsqu'un nombre important de classe enfant de AbstractDAO se pr\u00e9sente ? Est-il possible de factoriser ce code ? R\u00e9ponse OUI Solution : L'introspection permet aussi de r\u00e9cup\u00e9rer le type d'un g\u00e9n\u00e9rique. public abstract class AbstractDAO<E> { // ... protected Class<E> getEntityClass(){ // \u00c9tant donn\u00e9 que c'est la classe parent qui poss\u00e8de la notation en diamant. // On remonte donc vers cette derni\u00e8re avec l'introspection. // Il faut \u00e9galement transtyper la classe parent en 'ParameterizedType'. // Cela permet de faire l'introspection sur la notation en diamant. var type = (ParameterizedType) this.getClass().getGenericSuperclass(); // La m\u00e9thode 'getActualTypeArguments' permet de r\u00e9cup\u00e9rer un tableau de tous les g\u00e9n\u00e9riques. // La classe parent 'AbstractDAO' n'en poss\u00e8de q'un, il est \u00e0 l'index z\u00e9ro du tableau. // Encore une fois, il est n\u00e9cessaire de transtyper le r\u00e9sultat en 'Class<E>'. // Cela permet d'avoir le bon type de retour. var entityClass (Class<E>) type.getActualTypeArguments()[0]; // Ainsi, on peut r\u00e9cup\u00e9rer la classe de 'E' dynamiquement. // Les classes enfants n'ont plus besoin d'impl\u00e9menter cette m\u00e9thode. return entityClass; } } Note Malheureusement le transtypage est obligatoire ici. Java polymorphe les classes ici en java.lang.reflect.Type . Cette interface permet \u00e0 Java d'englober les notions : de variables, de primitives, de tableaux, de g\u00e9n\u00e9riques et m\u00eame de type brute. ` Mise en \u0153uvre Principe de fonctionnement Pour utiliser l'invocation dynamique, il est n\u00e9cessaire d'observer quelques r\u00e8gles : * Respecter la visibilit\u00e9 des attributs, des m\u00e9thodes, des classes. * Ne pas outrepasser cette visibilit\u00e9 * \u00catre extr\u00eamement pr\u00e9cis avec les param\u00e8tres lors de l'invocation dynamique. On conserve cette classe pour la d\u00e9monstration. package fr.zelmoacademy.model; public class Customer{ private String email; public Customer(){ } @Override public String toString() { return String.format( \"Customer{email=%s}\", email ); } // Accesseurs & Mutateurs // ... } var customer = new Customer(); System.out.println(customer); //> Sortie console: // Customer{email=null} // On souhaite changer la valeur de l'attribut 'email' par invocation dynamique. // On r\u00e9cup\u00e8re une instance de travail pour utiliser l'invocation dynamique. var lookup = MethodHandles.publicLookup(); // On pr\u00e9pare la signature de la m\u00e9thode cible avec le type de retour: // 1er param\u00e8tre: Type de retour. // 2nd param\u00e8tre: Type du premier argument. var setEmailSignature = MethodType.methodType(void.class, String.class); // On r\u00e9cup\u00e8re la m\u00e9thode cible: // 1er param\u00e8tre: Type de classe source. // 2e param\u00e8tre: Nom exact de la m\u00e9thode cible \u00e0 invoquer. // 3e param\u00e8tre: Type de retour et param\u00e8tre de la m\u00e9thode cible \u00e0 invoquer. // On obtiens une m\u00e9thode d'instance mais rattach\u00e9e \u00e0 aucun objet: '.setEmail()'. var setEmailHandler = lookup.findVirtual( Customer.class, \"setEmail\", setEmailSignature ); // Lier la m\u00e9thode dynamique avec l'instance r\u00e9elle. // On obtiens une m\u00e9thode d'instance rattach\u00e9 \u00e0 un objet: 'customer.setEmail()'. var setEmailBinded = setEmailHandler.bindTo(customer); // Invocation dynamique // On appel la m\u00e9thode avec les bons param\u00e8tres: 'customer.setEmail(\"john.doe@sample.com\")'. setEmailBinded.invokeExact(\"john.doe@sample.com\"); System.out.println(customer); //> Sortie console: // Customer{email=john.doe@sample.com} Cas pratique avanc\u00e9 Comment g\u00e9n\u00e9rer le r\u00e9sultat d'un m\u00e9thode toString de mani\u00e8re g\u00e9n\u00e9rique pour n'importe quel type d'objet ? A vous de coder ! Possible solution : package fr.zelmoacademy.util; import java.lang.invoke.MethodHandles; import java.lang.invoke.MethodType; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.ArrayList; import java.util.Collections; import java.util.Objects; /** * Utilitaire pour la g\u00e9n\u00e9ration de la m\u00e9thode <b>toString</b> des objets. */ public final class ToString { /** * Constructeur interne. Pas d'instanciation. */ private ToString() { throw new UnsupportedOperationException(\"No instance for you\"); } /** * G\u00e9n\u00e9rer gr\u00e2ce \u00e0 l'invocation dynamique l'\u00e9quivalent de la m\u00e9thode <b>toString</b> * pour n'importe quel type d'objet. * Cette m\u00e9thode utilise l'appel des accesseurs, * id\u00e9alement les objets devraient suivre la convention <b>JavaBean</b>. * * @param o Instance quelconque * @return Une cha\u00eene de caract\u00e8res repr\u00e9sentant les donn\u00e9es de cet objet. */ public static String generateDynamicToString(final Object o) { var fields = new ArrayList<Field>(); var getters = new ArrayList<Method>(); var objectClass = o.getClass(); do { // R\u00e9cup\u00e9ration de tous les attributs de la classe. var declaredFields = objectClass.getDeclaredFields(); Collections.addAll(fields, declaredFields); // R\u00e9cup\u00e9ration de tous les accesseurs. var declaredMethods = objectClass.getDeclaredMethods(); Collections.addAll(getters, declaredMethods); // Continuer tant que la classe parent n'est pas 'java.lang.Object'. // Ce qui permet de r\u00e9cup\u00e9rer les attributs et accesseurs des classes parent. objectClass = (Class<?>) objectClass.getGenericSuperclass(); } while (!Objects.equals(objectClass, Object.class)); // R\u00e9cup\u00e9ration de l'instance de travail pour utiliser l'invocation dynamique. var lookup = MethodHandles.publicLookup(); // Pr\u00e9paration de la cha\u00eene de caract\u00e8res finale. var text = new StringBuilder(); text.append(o.getClass().getName()); text.append(\"{\"); try { for (Field f : fields) { // R\u00e9cup\u00e9ration du le nom de l'attribut. var name = f.getName(); // R\u00e9cup\u00e9ration du type de l'attribut. var type = f.getType(); // Construction du pr\u00e9fix de l'accesseur. String getterPrefix; if (!Objects.equals(type, boolean.class)) { getterPrefix = \"get\"; } else { // Attention pour un attribut de type 'boolean' // l'accesseur commence par 'is'. getterPrefix = \"is\"; } // Construction du suffixe de l'accesseur. // Mettre la premi\u00e8re lettre du nom de l'attribut en majuscule. String getterSuffix; if (name.length() > 1) { getterSuffix = name.substring(0, 1).toUpperCase() + name.substring(1); } else { getterSuffix = name.toUpperCase(); } // Construction du nom de la m\u00e9thode de l'accesseur. var getterName = getterPrefix + getterSuffix; // Recherche de l'accesseur parmi les m\u00e9thodes existantes avec les crit\u00e8res suivants: // - Nom de m\u00e9thode identique // - Type de retour: 'void' // - Pas de param\u00e8tre // - M\u00e9thode publique. // L'objectif est de v\u00e9rifier l\u2019existence d'un accesseur pour un attribut donn\u00e9. // (Respect de la convention JavaBean) var getter = getters .stream() .filter(m -> Objects.equals(m.getName(), getterName)) .filter(m -> !Objects.equals(m.getReturnType(), void.class)) .filter(m -> m.getParameterCount() == 0) .filter(m -> m.getModifiers() == MethodHandles.Lookup.PUBLIC) .findFirst(); // Si l'accesseur existe, l'invocation peut commencer // Sinon pas d'invocation pour cet attribut. if (getter.isPresent()) { // On pr\u00e9pare la signature de la m\u00e9thode cible avec le type de retour var getterSignature = MethodType.methodType(type); // On r\u00e9cup\u00e8re la m\u00e9thode cible var getterHandler = lookup.findVirtual( o.getClass(), getterName, getterSignature ); // Lier la m\u00e9thode dynamique avec l'instance r\u00e9elle. var getterBinded = getterHandler.bindTo(o); // Invocation dynamique var getterValue = getterBinded.invoke(); // Construction de la cha\u00eene de caract\u00e8res. text.append(name); text.append(\"=\"); text.append(getterValue); text.append(\", \"); } } } catch (Throwable ex) { // L'invocation dynamique peut lever une exception si elle est mal r\u00e9alis\u00e9e. // L'exception n'est pas trait\u00e9e \u00e0 ce niveau. throw new IllegalStateException(ex); } // Supprimer des derniers caract\u00e8res superflus. var index = text.lastIndexOf(\",\"); var offset = 2; if (index >= 0 && text.length() > offset) { text.setLength(text.length() - offset); } // Fin de construction de la cha\u00eene de caract\u00e8res. text.append(\"}\"); return text.toString(); } } Usage: package fr.zelmoacademy.model import fr.zelmoacademy.util.ToString; public class Customer{ private String givenName; private String familyName; private String email; // Constructeurs // ... @Override public String toString(){ // Nouvelle impl\u00e9mentation. return ToString.generateDynamicToString(this); } // Accesseurs & Mutateurs // ... public static void main(String[] args){ var customer = new Customer(\"John\", \"DOE\", \"john.doe@example.com\"); System.out.println(customer); //> Sortie console: // fr.zelmoacademy.model.Customer{givenName=John, familyName=DOE, email=john.doe@example.com} } } [[dev:java:index|Retour au sommaire]]","title":"Invocation Dynamique"},{"location":"java/invoke_dynamic/#invocation-dynamique","text":"","title":"Invocation dynamique"},{"location":"java/invoke_dynamic/#introduction","text":"L'invocation dynamique est une technique avanc\u00e9e en Java pour appeler des m\u00e9thodes sans poss\u00e9der directement les objets concern\u00e9s. Avantages : * Code plus dynamique * Code plus g\u00e9n\u00e9rique Inconv\u00e9nient : * Concept complexe * Beaucoup plus verbeux Note Contrairement aux id\u00e9es re\u00e7ues, l'invocation dynamique en Java et m\u00eame plus rapide que l'appel classique de m\u00e9thodes (Quand elle respecte les r\u00e8gles de visibilit\u00e9s). La JVM sait optimiser ce code. En revanche l'invocation par r\u00e9flexion est \u00e0 \u00e9viter, elle est plus lente car la JVM ne peut optimiser ce code.","title":"` Introduction"},{"location":"java/invoke_dynamic/#introspection","text":"L'introspection est une technique avanc\u00e9e en Java permettant de parcourir la composition de la structure m\u00eame d'un objet, ou d'une classe par le code.","title":"Introspection"},{"location":"java/invoke_dynamic/#usage-basique","text":"package fr.zelmoacademy.model; public class Customer{ private String email; public Customer(){ } // Accesseurs & Mutateurs // ... } var customer = new Customer(); Field[] declaredFields = customer.getClass().getDeclaredFields(); ^^^^^^^^^^^^^^^^^-----// R\u00e9cup\u00e9ration de tous les attributs // d\u00e9clar\u00e9s dans la classe 'Customer'. System.out.println(Arrays.toString(declaredFields)); //> Sortie console: // [private java.lang.String fr.zelmoacademy.model.Customer.email] // On peut aussi faire l'instrospection de la classe directement // au lieu de passer par l'instance (*.getClass()). Method[] declaredMethods = Customer.class.getDeclaredMethods(); ^^^^^^^^^^^^^^^^^^-----// R\u00e9cup\u00e9ration de toutes les m\u00e9thodes // d\u00e9clar\u00e9s dans la classe 'Customer'. System.out.println(Arrays.toString(declaredMethods)); //> Sortie console: // [ // public void fr.zelmoacademy.model.Customer.setEmail(java.lang.String), // public java.lang.String fr.zelmoacademy.model.Customer.getEmail() // ] Type superClass = customer.getClass().getGenericSuperClass(); ^^^^^^^^^^^^^^^^^^^^^----// R\u00e9cup\u00e9rer la classe parent System.out.println(superClass); //> Sortie console: // class java.lang.Object Note Avec l'introspection vous pouvez naviguez dans la structure d'un classe est voir toutes ses caract\u00e9ristiques. cette approche permet en fonction de la structure d'un classe d'opter pour un comportement diff\u00e9rent dans votre algorithme.","title":"Usage basique"},{"location":"java/invoke_dynamic/#usage-avance","text":"Probl\u00e9matique : public class Customer { /* ... */ } public abstract class AbstractDAO<E> { // ... // On ne connait pas 'E'. // On d\u00e9l\u00e8gue ce traitement aux classes enfants. // Cette m\u00e9thode est donc abstraite. protected abstract Class<E> getEntityClass(); } public class CustomerDAO extends AbstractDAO<Customer> { // ... @Override protected Class<Customer> getEntityClass(){ // La classe concr\u00e8te r\u00e9sout la g\u00e9n\u00e9ricit\u00e9 // Par cons\u00e9quant, elle connait le type de 'E' // Il suffit d'impl\u00e9menter la m\u00e9thode. return Customer.class; } } Dans le code ci-dessus, on souhaite r\u00e9cup\u00e9rer la classe de E . Pour se faire, une mani\u00e8re simple est de passer par l'h\u00e9ritage. Cette m\u00e9thode est viable, mais que ce passe-t-il lorsqu'un nombre important de classe enfant de AbstractDAO se pr\u00e9sente ? Est-il possible de factoriser ce code ? R\u00e9ponse OUI Solution : L'introspection permet aussi de r\u00e9cup\u00e9rer le type d'un g\u00e9n\u00e9rique. public abstract class AbstractDAO<E> { // ... protected Class<E> getEntityClass(){ // \u00c9tant donn\u00e9 que c'est la classe parent qui poss\u00e8de la notation en diamant. // On remonte donc vers cette derni\u00e8re avec l'introspection. // Il faut \u00e9galement transtyper la classe parent en 'ParameterizedType'. // Cela permet de faire l'introspection sur la notation en diamant. var type = (ParameterizedType) this.getClass().getGenericSuperclass(); // La m\u00e9thode 'getActualTypeArguments' permet de r\u00e9cup\u00e9rer un tableau de tous les g\u00e9n\u00e9riques. // La classe parent 'AbstractDAO' n'en poss\u00e8de q'un, il est \u00e0 l'index z\u00e9ro du tableau. // Encore une fois, il est n\u00e9cessaire de transtyper le r\u00e9sultat en 'Class<E>'. // Cela permet d'avoir le bon type de retour. var entityClass (Class<E>) type.getActualTypeArguments()[0]; // Ainsi, on peut r\u00e9cup\u00e9rer la classe de 'E' dynamiquement. // Les classes enfants n'ont plus besoin d'impl\u00e9menter cette m\u00e9thode. return entityClass; } } Note Malheureusement le transtypage est obligatoire ici. Java polymorphe les classes ici en java.lang.reflect.Type . Cette interface permet \u00e0 Java d'englober les notions : de variables, de primitives, de tableaux, de g\u00e9n\u00e9riques et m\u00eame de type brute.","title":"Usage avanc\u00e9"},{"location":"java/invoke_dynamic/#mise-en-uvre","text":"","title":"` Mise en \u0153uvre"},{"location":"java/invoke_dynamic/#principe-de-fonctionnement","text":"Pour utiliser l'invocation dynamique, il est n\u00e9cessaire d'observer quelques r\u00e8gles : * Respecter la visibilit\u00e9 des attributs, des m\u00e9thodes, des classes. * Ne pas outrepasser cette visibilit\u00e9 * \u00catre extr\u00eamement pr\u00e9cis avec les param\u00e8tres lors de l'invocation dynamique. On conserve cette classe pour la d\u00e9monstration. package fr.zelmoacademy.model; public class Customer{ private String email; public Customer(){ } @Override public String toString() { return String.format( \"Customer{email=%s}\", email ); } // Accesseurs & Mutateurs // ... } var customer = new Customer(); System.out.println(customer); //> Sortie console: // Customer{email=null} // On souhaite changer la valeur de l'attribut 'email' par invocation dynamique. // On r\u00e9cup\u00e8re une instance de travail pour utiliser l'invocation dynamique. var lookup = MethodHandles.publicLookup(); // On pr\u00e9pare la signature de la m\u00e9thode cible avec le type de retour: // 1er param\u00e8tre: Type de retour. // 2nd param\u00e8tre: Type du premier argument. var setEmailSignature = MethodType.methodType(void.class, String.class); // On r\u00e9cup\u00e8re la m\u00e9thode cible: // 1er param\u00e8tre: Type de classe source. // 2e param\u00e8tre: Nom exact de la m\u00e9thode cible \u00e0 invoquer. // 3e param\u00e8tre: Type de retour et param\u00e8tre de la m\u00e9thode cible \u00e0 invoquer. // On obtiens une m\u00e9thode d'instance mais rattach\u00e9e \u00e0 aucun objet: '.setEmail()'. var setEmailHandler = lookup.findVirtual( Customer.class, \"setEmail\", setEmailSignature ); // Lier la m\u00e9thode dynamique avec l'instance r\u00e9elle. // On obtiens une m\u00e9thode d'instance rattach\u00e9 \u00e0 un objet: 'customer.setEmail()'. var setEmailBinded = setEmailHandler.bindTo(customer); // Invocation dynamique // On appel la m\u00e9thode avec les bons param\u00e8tres: 'customer.setEmail(\"john.doe@sample.com\")'. setEmailBinded.invokeExact(\"john.doe@sample.com\"); System.out.println(customer); //> Sortie console: // Customer{email=john.doe@sample.com}","title":"Principe de fonctionnement"},{"location":"java/invoke_dynamic/#cas-pratique-avance","text":"Comment g\u00e9n\u00e9rer le r\u00e9sultat d'un m\u00e9thode toString de mani\u00e8re g\u00e9n\u00e9rique pour n'importe quel type d'objet ? A vous de coder ! Possible solution : package fr.zelmoacademy.util; import java.lang.invoke.MethodHandles; import java.lang.invoke.MethodType; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.ArrayList; import java.util.Collections; import java.util.Objects; /** * Utilitaire pour la g\u00e9n\u00e9ration de la m\u00e9thode <b>toString</b> des objets. */ public final class ToString { /** * Constructeur interne. Pas d'instanciation. */ private ToString() { throw new UnsupportedOperationException(\"No instance for you\"); } /** * G\u00e9n\u00e9rer gr\u00e2ce \u00e0 l'invocation dynamique l'\u00e9quivalent de la m\u00e9thode <b>toString</b> * pour n'importe quel type d'objet. * Cette m\u00e9thode utilise l'appel des accesseurs, * id\u00e9alement les objets devraient suivre la convention <b>JavaBean</b>. * * @param o Instance quelconque * @return Une cha\u00eene de caract\u00e8res repr\u00e9sentant les donn\u00e9es de cet objet. */ public static String generateDynamicToString(final Object o) { var fields = new ArrayList<Field>(); var getters = new ArrayList<Method>(); var objectClass = o.getClass(); do { // R\u00e9cup\u00e9ration de tous les attributs de la classe. var declaredFields = objectClass.getDeclaredFields(); Collections.addAll(fields, declaredFields); // R\u00e9cup\u00e9ration de tous les accesseurs. var declaredMethods = objectClass.getDeclaredMethods(); Collections.addAll(getters, declaredMethods); // Continuer tant que la classe parent n'est pas 'java.lang.Object'. // Ce qui permet de r\u00e9cup\u00e9rer les attributs et accesseurs des classes parent. objectClass = (Class<?>) objectClass.getGenericSuperclass(); } while (!Objects.equals(objectClass, Object.class)); // R\u00e9cup\u00e9ration de l'instance de travail pour utiliser l'invocation dynamique. var lookup = MethodHandles.publicLookup(); // Pr\u00e9paration de la cha\u00eene de caract\u00e8res finale. var text = new StringBuilder(); text.append(o.getClass().getName()); text.append(\"{\"); try { for (Field f : fields) { // R\u00e9cup\u00e9ration du le nom de l'attribut. var name = f.getName(); // R\u00e9cup\u00e9ration du type de l'attribut. var type = f.getType(); // Construction du pr\u00e9fix de l'accesseur. String getterPrefix; if (!Objects.equals(type, boolean.class)) { getterPrefix = \"get\"; } else { // Attention pour un attribut de type 'boolean' // l'accesseur commence par 'is'. getterPrefix = \"is\"; } // Construction du suffixe de l'accesseur. // Mettre la premi\u00e8re lettre du nom de l'attribut en majuscule. String getterSuffix; if (name.length() > 1) { getterSuffix = name.substring(0, 1).toUpperCase() + name.substring(1); } else { getterSuffix = name.toUpperCase(); } // Construction du nom de la m\u00e9thode de l'accesseur. var getterName = getterPrefix + getterSuffix; // Recherche de l'accesseur parmi les m\u00e9thodes existantes avec les crit\u00e8res suivants: // - Nom de m\u00e9thode identique // - Type de retour: 'void' // - Pas de param\u00e8tre // - M\u00e9thode publique. // L'objectif est de v\u00e9rifier l\u2019existence d'un accesseur pour un attribut donn\u00e9. // (Respect de la convention JavaBean) var getter = getters .stream() .filter(m -> Objects.equals(m.getName(), getterName)) .filter(m -> !Objects.equals(m.getReturnType(), void.class)) .filter(m -> m.getParameterCount() == 0) .filter(m -> m.getModifiers() == MethodHandles.Lookup.PUBLIC) .findFirst(); // Si l'accesseur existe, l'invocation peut commencer // Sinon pas d'invocation pour cet attribut. if (getter.isPresent()) { // On pr\u00e9pare la signature de la m\u00e9thode cible avec le type de retour var getterSignature = MethodType.methodType(type); // On r\u00e9cup\u00e8re la m\u00e9thode cible var getterHandler = lookup.findVirtual( o.getClass(), getterName, getterSignature ); // Lier la m\u00e9thode dynamique avec l'instance r\u00e9elle. var getterBinded = getterHandler.bindTo(o); // Invocation dynamique var getterValue = getterBinded.invoke(); // Construction de la cha\u00eene de caract\u00e8res. text.append(name); text.append(\"=\"); text.append(getterValue); text.append(\", \"); } } } catch (Throwable ex) { // L'invocation dynamique peut lever une exception si elle est mal r\u00e9alis\u00e9e. // L'exception n'est pas trait\u00e9e \u00e0 ce niveau. throw new IllegalStateException(ex); } // Supprimer des derniers caract\u00e8res superflus. var index = text.lastIndexOf(\",\"); var offset = 2; if (index >= 0 && text.length() > offset) { text.setLength(text.length() - offset); } // Fin de construction de la cha\u00eene de caract\u00e8res. text.append(\"}\"); return text.toString(); } } Usage: package fr.zelmoacademy.model import fr.zelmoacademy.util.ToString; public class Customer{ private String givenName; private String familyName; private String email; // Constructeurs // ... @Override public String toString(){ // Nouvelle impl\u00e9mentation. return ToString.generateDynamicToString(this); } // Accesseurs & Mutateurs // ... public static void main(String[] args){ var customer = new Customer(\"John\", \"DOE\", \"john.doe@example.com\"); System.out.println(customer); //> Sortie console: // fr.zelmoacademy.model.Customer{givenName=John, familyName=DOE, email=john.doe@example.com} } } [[dev:java:index|Retour au sommaire]]","title":"Cas pratique avanc\u00e9"},{"location":"java/java_bean/","text":"Convention Java Bean Introduction Tr\u00e8s rependu en Jakarta EE , Java Bean est un concept \u00e0 maitriser! Un Java Bean est une classe dont son \u00e9criture doit respecter quelques r\u00e8gles. Les technologies de Jakarta EE s'appuient dessus pour fonctionner correctement. Principe de construction Voici les propri\u00e9t\u00e9s d'une classe Java Bean : La classe doit \u00eatre publique La classe doit \u00eatre d\u00e9rivable (que l'on puisse faire de l\u2019h\u00e9ritage) Impl\u00e9menter l'interface: java.io.Serializable Cela implique de poss\u00e9der la constante serialVersionUID Tous les attributs en doivent \u00eatre s\u00e9rialisable. Le constructeur doit \u00eatre public et sans param\u00e8tre. Les attributs sont \u00e0 priv\u00e9es. Les attributs poss\u00e8dent des accesseurs et des mutateurs publics. Note Si la classe repr\u00e9sente des donn\u00e9es m\u00e9tiers, impl\u00e9menter les m\u00e9thodes equals et hashCode . Et m\u00eame toString pour plus de lisibilit\u00e9. Exemple : package fr.zelmoacademy.model.entity; import java.io.Serializable; import java.util.Objects; // Classe publique. // Classe d\u00e9rivable. // Implemente 'java.io.Serializable'. public class Customer implements Serializable { // Num\u00e9ro de s\u00e9rie. private static final long serialVersionUID = 1L; // Attributs priv\u00e9s. // La classe 'java.lang.String' impl\u00e9mente aussi 'java.io.Serializable'. // Tous les attributs sont s\u00e9rialisables. private String givenName; private String familyName; // Constructeur par d\u00e9faut. // Visibilit\u00e9 publique. // Pas de param\u00e8tre. public Customer() { } // Facultatif: // Deuxi\u00e8me constructeur avec param\u00e8tre pour plus de confort. public Customer(final String givenName, final String familyName){ this.givenName = givenName; this.familyName = familyName; } // Red\u00e9finition de la m\u00e9thode car cette classe repr\u00e9sente des donn\u00e9es m\u00e9tiers. // Le calcul de l'\u00e9galit\u00e9 est bas\u00e9 sur les attributs 'givenName' et 'familyName'. @Override public boolean equals(Object o) { final boolean eq; if (this == o) { eq = true; } else if (!(o instanceof Customer)) { eq = false; } else { var other = (Customer) o; eq = Objects.equals(givenName, other.givenName) && Objects.equals(familyName, other.familyName); } return eq; } // Red\u00e9finition de la m\u00e9thode. // Lorsque l'on red\u00e9finit l'\u00e9galit\u00e9 d'un objet, il faut obligatoirement red\u00e9finir 'equals' et 'hashCode'. // Le calcul de l'\u00e9galit\u00e9 est bas\u00e9 sur les m\u00eame attributs que la m\u00e9thode 'equals'. @Override public int hashCode() { return Objects.hash(givenName, familyName); } // Red\u00e9finition de la m\u00e9thode. // Plus de confort pour les d\u00e9veloppeurs. @Override public String toString() { return String.format( \"%s{givenName=%s, familyName=%s}\", getClass().getName(), this.givenName, this.familyName ); } // Accesseurs & Mutateurs. // Principe d'encapsulation. public String getGivenName() { return givenName; } public void setGivenName(String givenName) { this.givenName = givenName; } public String getFamilyName() { return familyName; } public void setFamilyName(String familyName) { this.familyName = familyName; } } Note La plupart des technologies Jakarta EE s'appuie sur Java Bean pour fonctionner correctement, on peut citer par exemple : JPA , EJB , CDI ... M\u00e9canisme de s\u00e9rialisation La s\u00e9rialisation est un m\u00e9canisme apparu en Java 1.1 avec l'interface java.io.Serializable . Ce m\u00e9canisme est donc tr\u00e8s vieux. Il permet \u00e0 la JVM de transformer une instance de classe en flux de donn\u00e9es binaire dont l'\u00e9tat peut \u00eatre sauvegard\u00e9 dans un fichier (s\u00e9rialis\u00e9) puis \u00eatre relu (d\u00e9-s\u00e9rialis\u00e9) pour restituer l'\u00e9tat d'un programme. Afin de garantir que le m\u00e9canisme de s\u00e9rialisation et d\u00e9-s\u00e9rialisation fonctionne correctement, la //JVM// s'appuie sur la constante serialVersionUID . Une sorte de num\u00e9ro de s\u00e9rie de la classe. Si cette constante n'existe pas, c'est la JVM qui l'ajoute. La bonne pratique \u00e9tant bien s\u00fbr de g\u00e9n\u00e9rer soit-m\u00eame cet attribut afin d'all\u00e9ger le traitement de la //JVM//.","title":"Convention Java Bean"},{"location":"java/java_bean/#convention-java-bean","text":"","title":"Convention Java Bean"},{"location":"java/java_bean/#introduction","text":"Tr\u00e8s rependu en Jakarta EE , Java Bean est un concept \u00e0 maitriser! Un Java Bean est une classe dont son \u00e9criture doit respecter quelques r\u00e8gles. Les technologies de Jakarta EE s'appuient dessus pour fonctionner correctement.","title":"Introduction"},{"location":"java/java_bean/#principe-de-construction","text":"Voici les propri\u00e9t\u00e9s d'une classe Java Bean : La classe doit \u00eatre publique La classe doit \u00eatre d\u00e9rivable (que l'on puisse faire de l\u2019h\u00e9ritage) Impl\u00e9menter l'interface: java.io.Serializable Cela implique de poss\u00e9der la constante serialVersionUID Tous les attributs en doivent \u00eatre s\u00e9rialisable. Le constructeur doit \u00eatre public et sans param\u00e8tre. Les attributs sont \u00e0 priv\u00e9es. Les attributs poss\u00e8dent des accesseurs et des mutateurs publics. Note Si la classe repr\u00e9sente des donn\u00e9es m\u00e9tiers, impl\u00e9menter les m\u00e9thodes equals et hashCode . Et m\u00eame toString pour plus de lisibilit\u00e9. Exemple : package fr.zelmoacademy.model.entity; import java.io.Serializable; import java.util.Objects; // Classe publique. // Classe d\u00e9rivable. // Implemente 'java.io.Serializable'. public class Customer implements Serializable { // Num\u00e9ro de s\u00e9rie. private static final long serialVersionUID = 1L; // Attributs priv\u00e9s. // La classe 'java.lang.String' impl\u00e9mente aussi 'java.io.Serializable'. // Tous les attributs sont s\u00e9rialisables. private String givenName; private String familyName; // Constructeur par d\u00e9faut. // Visibilit\u00e9 publique. // Pas de param\u00e8tre. public Customer() { } // Facultatif: // Deuxi\u00e8me constructeur avec param\u00e8tre pour plus de confort. public Customer(final String givenName, final String familyName){ this.givenName = givenName; this.familyName = familyName; } // Red\u00e9finition de la m\u00e9thode car cette classe repr\u00e9sente des donn\u00e9es m\u00e9tiers. // Le calcul de l'\u00e9galit\u00e9 est bas\u00e9 sur les attributs 'givenName' et 'familyName'. @Override public boolean equals(Object o) { final boolean eq; if (this == o) { eq = true; } else if (!(o instanceof Customer)) { eq = false; } else { var other = (Customer) o; eq = Objects.equals(givenName, other.givenName) && Objects.equals(familyName, other.familyName); } return eq; } // Red\u00e9finition de la m\u00e9thode. // Lorsque l'on red\u00e9finit l'\u00e9galit\u00e9 d'un objet, il faut obligatoirement red\u00e9finir 'equals' et 'hashCode'. // Le calcul de l'\u00e9galit\u00e9 est bas\u00e9 sur les m\u00eame attributs que la m\u00e9thode 'equals'. @Override public int hashCode() { return Objects.hash(givenName, familyName); } // Red\u00e9finition de la m\u00e9thode. // Plus de confort pour les d\u00e9veloppeurs. @Override public String toString() { return String.format( \"%s{givenName=%s, familyName=%s}\", getClass().getName(), this.givenName, this.familyName ); } // Accesseurs & Mutateurs. // Principe d'encapsulation. public String getGivenName() { return givenName; } public void setGivenName(String givenName) { this.givenName = givenName; } public String getFamilyName() { return familyName; } public void setFamilyName(String familyName) { this.familyName = familyName; } } Note La plupart des technologies Jakarta EE s'appuie sur Java Bean pour fonctionner correctement, on peut citer par exemple : JPA , EJB , CDI ...","title":"Principe de construction"},{"location":"java/java_bean/#mecanisme-de-serialisation","text":"La s\u00e9rialisation est un m\u00e9canisme apparu en Java 1.1 avec l'interface java.io.Serializable . Ce m\u00e9canisme est donc tr\u00e8s vieux. Il permet \u00e0 la JVM de transformer une instance de classe en flux de donn\u00e9es binaire dont l'\u00e9tat peut \u00eatre sauvegard\u00e9 dans un fichier (s\u00e9rialis\u00e9) puis \u00eatre relu (d\u00e9-s\u00e9rialis\u00e9) pour restituer l'\u00e9tat d'un programme. Afin de garantir que le m\u00e9canisme de s\u00e9rialisation et d\u00e9-s\u00e9rialisation fonctionne correctement, la //JVM// s'appuie sur la constante serialVersionUID . Une sorte de num\u00e9ro de s\u00e9rie de la classe. Si cette constante n'existe pas, c'est la JVM qui l'ajoute. La bonne pratique \u00e9tant bien s\u00fbr de g\u00e9n\u00e9rer soit-m\u00eame cet attribut afin d'all\u00e9ger le traitement de la //JVM//.","title":"M\u00e9canisme de s\u00e9rialisation"},{"location":"java/javadoc/","text":"Documentation Java Introduction Le code Java doit \u00eatre document\u00e9 afin d'aider les autres d\u00e9veloppeurs \u00e0 reprendre votre code et l'utiliser correctement. Cette documentation nomm\u00e9e JavaDoc poss\u00e8de des r\u00e8gles de syntaxes particuli\u00e8res et n'est pas \u00e0 confondre avec les commentaires. En Java, la JavaDoc rev\u00eat un caract\u00e8re officiel, il est m\u00eame possible de g\u00e9n\u00e9rer un site HTML statique avec toute la documentation de votre code. Alors que le commentaire est beaucoup plus libre et informel, il offre des d\u00e9tails ponctuels dans le code. R\u00e8gles d'\u00e9critures Syntaxe Il y a plusieurs r\u00e8gles \u00e0 respecter lors de l'\u00e9criture de la JavaDoc . Si elles ne sont pas respect\u00e9es des erreurs se produiront \u00e0 la g\u00e9n\u00e9ration de la documentation. **R\u00e8gles de d\u00e9claration : /** * */ Ne peut se placer uniquement sur : Les classes Les m\u00e9thodes Les attributs La documentation doit commencer par une majuscule et se finir par un point. Les g\u00e9n\u00e9ricit\u00e9s doivent appara\u00eetre dans la documentation. Le retour d'une m\u00e9thode appara\u00eetre dans la documentation. Les param\u00e8tres de m\u00e9thode doivent appara\u00eetre dans la documentation. Annotation Afin d'enrichir la documentation, il est possible de placer des annotations. A conna\u00eetre : * @param : Suivit d'un nom du param\u00e8tre ou du g\u00e9n\u00e9rique pour le documenter. * @return : Documenter le r\u00e9sultat d'une m\u00e9thode. * @throws : Documenter le ou les exceptions lev\u00e9es par une m\u00e9thode quelles soit d\u00e9clar\u00e9es dans la signature ou non. * @exception Documenter le ou les exceptions que l'appel de la m\u00e9thode peut engendrer implicitement. * @author Indique l'auteur de la classe ou m\u00e9thode. * @since Indique la version de l'application quand la classe ou la m\u00e9thode a \u00e9t\u00e9 cr\u00e9\u00e9e. * @deprecated Documenter pourquoi cet \u00e9l\u00e9ment est d\u00e9pr\u00e9ci\u00e9. * @see Suivit du nom complet de classe pour indiquer une r\u00e9f\u00e9rence documentaire. Certaines annotations peuvent s'\u00e9crire entre accolades pour consid\u00e9rer un bloc: /** {@code Objects.equals(a, b)} */ ^^^^^^^^^^^^^^^^^^^^---// Petit bloc de code Java en une ligne /** {@link Comparable} */ ^^^^^^^^^^-------------// Lien vers une autre classe Exemple : /** * Classe m\u00e8re pour toutes les op\u00e9rations de persistances g\u00e9n\u00e9riques. * Se base sur la technologie Jakarta EE JPA. * * @param <E> Une entit\u00e9 persistante s\u00e9rialisable * @author Moselle Academy * @see Serializable * @since 1.0 */ public abstract class AbstractDAO<E extends Serializable>{ /** * Sauvegarder une entit\u00e9 dans le contexte de persistance. * * @param entity Une entit\u00e9 persistante \u00e0 cr\u00e9er ou mettre \u00e0 jour * @return La valeur {@code true} si et seulement si l'\u00e9tat de la base de donn\u00e9es \u00e0 chang\u00e9, * sinon la valeur {@code false} est retourn\u00e9e * @throws DAOException si l'entit\u00e9 ne respecte pas les contraintes d'int\u00e9grit\u00e9 de la base de donn\u00e9es */ public boolean save(E entity) throws DAOException { // ... } /** * Mettre \u00e0 jour une entit\u00e9 dans le contexte de persistance. * * @param entity entit\u00e9 persistante \u00e0 mettre \u00e0 jour * @deprecated Remplacer par la m\u00e9thode {@code AbstractDAO.save(entity)} */ @Deprecated public void update(E entity){ // ... } } Mise en forme La JavaDoc supporte \u00e9galement les balises HTML pour des mises en formes avanc\u00e9es. Ces balises peuvent poss\u00e9der l'attribut style pour utiliser les propri\u00e9t\u00e9s CSS . Exemple : /** * Repr\u00e9sente un consommateur de l'application <b>BeeNews</b>. * Un consommateur peut: * <ul> * <li>Acheter un produit.</li> * <li>Consulter ses factures.</li> * <li>Cr\u00e9diter sa carte de fid\u00e9lit\u00e9.</li> * <li>Mettre \u00e0 jour ses informations de compte.</li> * </ul> * <b style=\"color:red;\">Toutes les actions m\u00e9tiers d'un consommateur seront trac\u00e9es.</b> * * @author Moselle Academy */ public class Customer implements Serializable { // ... /** * Constructeur par d\u00e9faut. * Requis pour le fonctionnement nominal de la s\u00e9rialisation. * * <pre> * var cutomer = new Customer(); * customer.setGivenName(\"John\"); * customer.setFamilyName(\"DOE\"); * customer.setEmail(\"john.doe@sample.org\"); * </pre> * @see #setGivenName() * @see #setFamilyName() * @see #setEmail() */ public Customer() { } // Accesseurs & Mutateurs // ... } Note Vous pouvez ins\u00e9rer des blocs de code sur plusieurs lignes en conservant le formatage avec la balise pre . Vous pouvez \u00e9galement utiliser la syntaxe # pour placer une ancre vers une m\u00e9thode, un attribut ou une constante de cette m\u00eame classe.","title":"Documentation"},{"location":"java/javadoc/#documentation-java","text":"","title":"Documentation Java"},{"location":"java/javadoc/#introduction","text":"Le code Java doit \u00eatre document\u00e9 afin d'aider les autres d\u00e9veloppeurs \u00e0 reprendre votre code et l'utiliser correctement. Cette documentation nomm\u00e9e JavaDoc poss\u00e8de des r\u00e8gles de syntaxes particuli\u00e8res et n'est pas \u00e0 confondre avec les commentaires. En Java, la JavaDoc rev\u00eat un caract\u00e8re officiel, il est m\u00eame possible de g\u00e9n\u00e9rer un site HTML statique avec toute la documentation de votre code. Alors que le commentaire est beaucoup plus libre et informel, il offre des d\u00e9tails ponctuels dans le code.","title":"Introduction"},{"location":"java/javadoc/#regles-decritures","text":"","title":"R\u00e8gles d'\u00e9critures"},{"location":"java/javadoc/#syntaxe","text":"Il y a plusieurs r\u00e8gles \u00e0 respecter lors de l'\u00e9criture de la JavaDoc . Si elles ne sont pas respect\u00e9es des erreurs se produiront \u00e0 la g\u00e9n\u00e9ration de la documentation. **R\u00e8gles de d\u00e9claration : /** * */ Ne peut se placer uniquement sur : Les classes Les m\u00e9thodes Les attributs La documentation doit commencer par une majuscule et se finir par un point. Les g\u00e9n\u00e9ricit\u00e9s doivent appara\u00eetre dans la documentation. Le retour d'une m\u00e9thode appara\u00eetre dans la documentation. Les param\u00e8tres de m\u00e9thode doivent appara\u00eetre dans la documentation.","title":"Syntaxe"},{"location":"java/javadoc/#annotation","text":"Afin d'enrichir la documentation, il est possible de placer des annotations. A conna\u00eetre : * @param : Suivit d'un nom du param\u00e8tre ou du g\u00e9n\u00e9rique pour le documenter. * @return : Documenter le r\u00e9sultat d'une m\u00e9thode. * @throws : Documenter le ou les exceptions lev\u00e9es par une m\u00e9thode quelles soit d\u00e9clar\u00e9es dans la signature ou non. * @exception Documenter le ou les exceptions que l'appel de la m\u00e9thode peut engendrer implicitement. * @author Indique l'auteur de la classe ou m\u00e9thode. * @since Indique la version de l'application quand la classe ou la m\u00e9thode a \u00e9t\u00e9 cr\u00e9\u00e9e. * @deprecated Documenter pourquoi cet \u00e9l\u00e9ment est d\u00e9pr\u00e9ci\u00e9. * @see Suivit du nom complet de classe pour indiquer une r\u00e9f\u00e9rence documentaire. Certaines annotations peuvent s'\u00e9crire entre accolades pour consid\u00e9rer un bloc: /** {@code Objects.equals(a, b)} */ ^^^^^^^^^^^^^^^^^^^^---// Petit bloc de code Java en une ligne /** {@link Comparable} */ ^^^^^^^^^^-------------// Lien vers une autre classe Exemple : /** * Classe m\u00e8re pour toutes les op\u00e9rations de persistances g\u00e9n\u00e9riques. * Se base sur la technologie Jakarta EE JPA. * * @param <E> Une entit\u00e9 persistante s\u00e9rialisable * @author Moselle Academy * @see Serializable * @since 1.0 */ public abstract class AbstractDAO<E extends Serializable>{ /** * Sauvegarder une entit\u00e9 dans le contexte de persistance. * * @param entity Une entit\u00e9 persistante \u00e0 cr\u00e9er ou mettre \u00e0 jour * @return La valeur {@code true} si et seulement si l'\u00e9tat de la base de donn\u00e9es \u00e0 chang\u00e9, * sinon la valeur {@code false} est retourn\u00e9e * @throws DAOException si l'entit\u00e9 ne respecte pas les contraintes d'int\u00e9grit\u00e9 de la base de donn\u00e9es */ public boolean save(E entity) throws DAOException { // ... } /** * Mettre \u00e0 jour une entit\u00e9 dans le contexte de persistance. * * @param entity entit\u00e9 persistante \u00e0 mettre \u00e0 jour * @deprecated Remplacer par la m\u00e9thode {@code AbstractDAO.save(entity)} */ @Deprecated public void update(E entity){ // ... } }","title":"Annotation"},{"location":"java/javadoc/#mise-en-forme","text":"La JavaDoc supporte \u00e9galement les balises HTML pour des mises en formes avanc\u00e9es. Ces balises peuvent poss\u00e9der l'attribut style pour utiliser les propri\u00e9t\u00e9s CSS . Exemple : /** * Repr\u00e9sente un consommateur de l'application <b>BeeNews</b>. * Un consommateur peut: * <ul> * <li>Acheter un produit.</li> * <li>Consulter ses factures.</li> * <li>Cr\u00e9diter sa carte de fid\u00e9lit\u00e9.</li> * <li>Mettre \u00e0 jour ses informations de compte.</li> * </ul> * <b style=\"color:red;\">Toutes les actions m\u00e9tiers d'un consommateur seront trac\u00e9es.</b> * * @author Moselle Academy */ public class Customer implements Serializable { // ... /** * Constructeur par d\u00e9faut. * Requis pour le fonctionnement nominal de la s\u00e9rialisation. * * <pre> * var cutomer = new Customer(); * customer.setGivenName(\"John\"); * customer.setFamilyName(\"DOE\"); * customer.setEmail(\"john.doe@sample.org\"); * </pre> * @see #setGivenName() * @see #setFamilyName() * @see #setEmail() */ public Customer() { } // Accesseurs & Mutateurs // ... } Note Vous pouvez ins\u00e9rer des blocs de code sur plusieurs lignes en conservant le formatage avec la balise pre . Vous pouvez \u00e9galement utiliser la syntaxe # pour placer une ancre vers une m\u00e9thode, un attribut ou une constante de cette m\u00eame classe.","title":"Mise en forme"},{"location":"java/organization/","text":"Organisation des classes Java Introduction Dans un projet Java, les classes sont regroup\u00e9es dans des r\u00e9pertoires appel\u00e9s packages . Ces packages permettent d'organiser votre code et de former l'architecture logicielle de votre application. Un d\u00e9veloppeur doit comprendre \u00e0 la simple vue des packages l'intention de l\u2019architecture logicielle. Notion de racine Tout projet Java se doit d'organiser ses packages sous forme d'arborescence logique. Pour ce faire on d\u00e9termine une racine. Le ou les packages racines ont pour but de donn\u00e9es une r\u00e9elle identit\u00e9 \u00e0 vos classes, c'est de l\u00e0 que part toute l'architecture. On applique pour cela la convention de nommage dit du reserve DNS (ou nom de domaine invers\u00e9). Exemple : Pour Google, le package racine est le suivant : com.google . Pour la Fondation Apache : org.apache . Pour la Fondation Eclipse : org.eclipse . etc... Note Vous l'avez compris le package racine se construit sur ce motif : <Nom de domaine invers\u00e9>.<Nom du projet> . Notion de coh\u00e9sion D\u00e9finition : Une classe est en d\u00e9pendance avec une autre classe si : Cette derni\u00e8re est d\u00e9clar\u00e9e dans ses imports. Une classe est en coh\u00e9sion avec une autre classe si : Elle est en relation avec cette autre classe. Elle n'est pas d\u00e9clar\u00e9e dans ses imports. Une classe n'est pas en coh\u00e9sion avec d'autres classes si : Elle n'est pas en relation avec les classes de son package . Note En Java les classes d'un m\u00eame package n'ont pas besoin de s'importer mutuellement. Pour v\u00e9rifier la coh\u00e9sion d'une classe il suffit de regarder ses imports. Plus une classe poss\u00e8de d'import de classe du m\u00eame projet, plus sa coh\u00e9sion est faible. Une classe poss\u00e9dant trop d'import indique \u00e9galement que la classe \u00e0 trop de responsabilit\u00e9, et donc qu'elle pourrait \u00eatre d\u00e9coup\u00e9e en de plus petites classes. Organisation par couche L'organisation par couche est la plus rependue aupr\u00e8s des d\u00e9veloppeurs, elle est \u00e9galement simple \u00e0 mettre en place. En revanche les classes manques de coh\u00e9sion entre elles. Dans un projet Jakarta EE voici un exemple d'organisation : Partie EJB : + fr.zelmoacademy.example + model - data - entity - mapper - repository - service - security - util Partie WAR : + fr.zelmoacademy.example.client - controller + model - data - form - mapper - security - view - util L\u00e9gende : model : Regroupe les classes repr\u00e9sentants les donn\u00e9es ainsi que les classes qui les transforment. data : Regroupe les classes de type DTO (Data Transfer Object) . entity : Regroupe les classes de type entit\u00e9 m\u00e9tier. mapper : Regroupe les classes qui transforment les DTO en d'autres types de DTO ou d'entit\u00e9 et r\u00e9ciproquement. repository : Regroupe les classes de type DAO (Data Access Object) . service : Regroupe les classes de traitement (comme les cas d'utilisation). util : Regroupe les classes utilitaires. controller : Regroupe les classes de type Contr\u00f4leur qui permettent d'interroger l'application depuis l\u2019ext\u00e9rieur. form : Regroupe les classes de type Formulaire , ce sont des DTO mais pour des pages de formulaire web. security : Regroupe les classes d\u00e9di\u00e9es \u00e0 la mise en \u0153uvre de la s\u00e9curit\u00e9. view : Regroupe les classes d\u00e9di\u00e9es sp\u00e9cifiquement \u00e0 la vue. Note Bien entendu, vous pouvez d\u00e9cliner cette organisation en fonction du projet. Ou encore privil\u00e9gier d'autre nom pour vos packages (exemple: dao au lieu de repository , dto au lieu de data ...). Organisation par fonctionnalit\u00e9s L'organisation par fonctionnalit\u00e9 permet d'augmenter la coh\u00e9sion entre les classes en les regroupant par traitement. Chaque fonctionnalit\u00e9s doit \u00eatre ind\u00e9pendantes des autres, ce qui limite grandement les effets de bord. Mais elle n\u00e9cessite un d\u00e9coupe m\u00e9tier beaucoup plus rigoureux. Partie EJB : + fr.zelmoacademy.example - common - feature1 - feature2 - feature3 - security - util Partie WAR : + fr.zelmoacademy.example.client - common - feature1 - feature2 - feature3 - security - util L\u00e9gende : feature : A renommer par le nom de la fonctionnalit\u00e9 r\u00e9elle. Ce package est sp\u00e9cifique, il ne d\u00e9pend que de common et util . common : Regroupe les classes communes entre les fonctionnalit\u00e9s. A pr\u00e9sent, dans la partie EJB chaque package de fonctionnalit\u00e9 regroupe : les entit\u00e9s m\u00e9tiers, les DTO , les DAO , le ou les services ... La partie WAR reprend ce principe \u00e9galement mais pour les contr\u00f4leurs , formulaires , DTO ... Organisation par technologie Cette organisation est un d\u00e9coupage avanc\u00e9 par technologie. Il isole le m\u00e9tier cod\u00e9 en pure Java afin de pouvoir d\u00e9cider de la technologie \u00e0 utiliser le plus tardivement possible. Ou de pouvoir changer de technologie en r\u00e9duisant le co\u00fbt technique. Note Cette organisation rel\u00e8ve d'une architecture nomm\u00e9e : Clean Architecture ou Architecture Hexagonale . Elle est plus complexe \u00e0 mettre en \u0153uvre et n\u00e9cessite plus de code. A privil\u00e9gier uniquement pour des gros projets avec des r\u00e8gles m\u00e9tiers et des enjeux techniques. Partie JAR en pure Java, pas de d\u00e9pendances externes: + fr.zelmoacademy.example.core + model - data - gateway - business - util OU + fr.zelmoacademy.example.core - common - feature1 - feature2 - feature3 - util Partie EJB : + fr.zelmoacademy.example + persistence - entity - mapper - repository - service - security - util Partie WAR : + fr.zelmoacademy.example.client + controller + model - data - form - mapper - security - view - util L\u00e9gende : core : Ce package contient tout le c\u0153ur m\u00e9tier de l'application en pure Java, sans d\u00e9pendances externes. gateway : Pour passerelle, c'est un terme tr\u00e8s g\u00e9n\u00e9rique pour englober la notion d'entrep\u00f4t ( repository ), de service web, d'annuaire ou tout ce qui consiste \u00e0 la lecture/\u00e9crire d'objet en dehors de l'application. business : Contient les classes r\u00e9alisant les traitements m\u00e9tiers (cas d'utilisation). persistence : Ce package est d\u00e9di\u00e9 \u00e0 l'emploi de la technologie de persistance, en Jakarta EE il s'agit de JPA . Le package mapper permet la conversion entre les entit\u00e9s persistantes et les objets du c\u0153ur m\u00e9tier. service : Ce package est d\u00e9di\u00e9 \u00e0 l'emploi de la technologie de traitement, en Jakarta EE il s'agit d' EJB .","title":"Organisation du code"},{"location":"java/organization/#organisation-des-classes-java","text":"","title":"Organisation des classes Java"},{"location":"java/organization/#introduction","text":"Dans un projet Java, les classes sont regroup\u00e9es dans des r\u00e9pertoires appel\u00e9s packages . Ces packages permettent d'organiser votre code et de former l'architecture logicielle de votre application. Un d\u00e9veloppeur doit comprendre \u00e0 la simple vue des packages l'intention de l\u2019architecture logicielle.","title":"Introduction"},{"location":"java/organization/#notion-de-racine","text":"Tout projet Java se doit d'organiser ses packages sous forme d'arborescence logique. Pour ce faire on d\u00e9termine une racine. Le ou les packages racines ont pour but de donn\u00e9es une r\u00e9elle identit\u00e9 \u00e0 vos classes, c'est de l\u00e0 que part toute l'architecture. On applique pour cela la convention de nommage dit du reserve DNS (ou nom de domaine invers\u00e9). Exemple : Pour Google, le package racine est le suivant : com.google . Pour la Fondation Apache : org.apache . Pour la Fondation Eclipse : org.eclipse . etc... Note Vous l'avez compris le package racine se construit sur ce motif : <Nom de domaine invers\u00e9>.<Nom du projet> .","title":"Notion de racine"},{"location":"java/organization/#notion-de-cohesion","text":"D\u00e9finition : Une classe est en d\u00e9pendance avec une autre classe si : Cette derni\u00e8re est d\u00e9clar\u00e9e dans ses imports. Une classe est en coh\u00e9sion avec une autre classe si : Elle est en relation avec cette autre classe. Elle n'est pas d\u00e9clar\u00e9e dans ses imports. Une classe n'est pas en coh\u00e9sion avec d'autres classes si : Elle n'est pas en relation avec les classes de son package . Note En Java les classes d'un m\u00eame package n'ont pas besoin de s'importer mutuellement. Pour v\u00e9rifier la coh\u00e9sion d'une classe il suffit de regarder ses imports. Plus une classe poss\u00e8de d'import de classe du m\u00eame projet, plus sa coh\u00e9sion est faible. Une classe poss\u00e9dant trop d'import indique \u00e9galement que la classe \u00e0 trop de responsabilit\u00e9, et donc qu'elle pourrait \u00eatre d\u00e9coup\u00e9e en de plus petites classes.","title":"Notion de coh\u00e9sion"},{"location":"java/organization/#organisation-par-couche","text":"L'organisation par couche est la plus rependue aupr\u00e8s des d\u00e9veloppeurs, elle est \u00e9galement simple \u00e0 mettre en place. En revanche les classes manques de coh\u00e9sion entre elles. Dans un projet Jakarta EE voici un exemple d'organisation : Partie EJB : + fr.zelmoacademy.example + model - data - entity - mapper - repository - service - security - util Partie WAR : + fr.zelmoacademy.example.client - controller + model - data - form - mapper - security - view - util L\u00e9gende : model : Regroupe les classes repr\u00e9sentants les donn\u00e9es ainsi que les classes qui les transforment. data : Regroupe les classes de type DTO (Data Transfer Object) . entity : Regroupe les classes de type entit\u00e9 m\u00e9tier. mapper : Regroupe les classes qui transforment les DTO en d'autres types de DTO ou d'entit\u00e9 et r\u00e9ciproquement. repository : Regroupe les classes de type DAO (Data Access Object) . service : Regroupe les classes de traitement (comme les cas d'utilisation). util : Regroupe les classes utilitaires. controller : Regroupe les classes de type Contr\u00f4leur qui permettent d'interroger l'application depuis l\u2019ext\u00e9rieur. form : Regroupe les classes de type Formulaire , ce sont des DTO mais pour des pages de formulaire web. security : Regroupe les classes d\u00e9di\u00e9es \u00e0 la mise en \u0153uvre de la s\u00e9curit\u00e9. view : Regroupe les classes d\u00e9di\u00e9es sp\u00e9cifiquement \u00e0 la vue. Note Bien entendu, vous pouvez d\u00e9cliner cette organisation en fonction du projet. Ou encore privil\u00e9gier d'autre nom pour vos packages (exemple: dao au lieu de repository , dto au lieu de data ...).","title":"Organisation par couche"},{"location":"java/organization/#organisation-par-fonctionnalites","text":"L'organisation par fonctionnalit\u00e9 permet d'augmenter la coh\u00e9sion entre les classes en les regroupant par traitement. Chaque fonctionnalit\u00e9s doit \u00eatre ind\u00e9pendantes des autres, ce qui limite grandement les effets de bord. Mais elle n\u00e9cessite un d\u00e9coupe m\u00e9tier beaucoup plus rigoureux. Partie EJB : + fr.zelmoacademy.example - common - feature1 - feature2 - feature3 - security - util Partie WAR : + fr.zelmoacademy.example.client - common - feature1 - feature2 - feature3 - security - util L\u00e9gende : feature : A renommer par le nom de la fonctionnalit\u00e9 r\u00e9elle. Ce package est sp\u00e9cifique, il ne d\u00e9pend que de common et util . common : Regroupe les classes communes entre les fonctionnalit\u00e9s. A pr\u00e9sent, dans la partie EJB chaque package de fonctionnalit\u00e9 regroupe : les entit\u00e9s m\u00e9tiers, les DTO , les DAO , le ou les services ... La partie WAR reprend ce principe \u00e9galement mais pour les contr\u00f4leurs , formulaires , DTO ...","title":"Organisation par fonctionnalit\u00e9s"},{"location":"java/organization/#organisation-par-technologie","text":"Cette organisation est un d\u00e9coupage avanc\u00e9 par technologie. Il isole le m\u00e9tier cod\u00e9 en pure Java afin de pouvoir d\u00e9cider de la technologie \u00e0 utiliser le plus tardivement possible. Ou de pouvoir changer de technologie en r\u00e9duisant le co\u00fbt technique. Note Cette organisation rel\u00e8ve d'une architecture nomm\u00e9e : Clean Architecture ou Architecture Hexagonale . Elle est plus complexe \u00e0 mettre en \u0153uvre et n\u00e9cessite plus de code. A privil\u00e9gier uniquement pour des gros projets avec des r\u00e8gles m\u00e9tiers et des enjeux techniques. Partie JAR en pure Java, pas de d\u00e9pendances externes: + fr.zelmoacademy.example.core + model - data - gateway - business - util OU + fr.zelmoacademy.example.core - common - feature1 - feature2 - feature3 - util Partie EJB : + fr.zelmoacademy.example + persistence - entity - mapper - repository - service - security - util Partie WAR : + fr.zelmoacademy.example.client + controller + model - data - form - mapper - security - view - util L\u00e9gende : core : Ce package contient tout le c\u0153ur m\u00e9tier de l'application en pure Java, sans d\u00e9pendances externes. gateway : Pour passerelle, c'est un terme tr\u00e8s g\u00e9n\u00e9rique pour englober la notion d'entrep\u00f4t ( repository ), de service web, d'annuaire ou tout ce qui consiste \u00e0 la lecture/\u00e9crire d'objet en dehors de l'application. business : Contient les classes r\u00e9alisant les traitements m\u00e9tiers (cas d'utilisation). persistence : Ce package est d\u00e9di\u00e9 \u00e0 l'emploi de la technologie de persistance, en Jakarta EE il s'agit de JPA . Le package mapper permet la conversion entre les entit\u00e9s persistantes et les objets du c\u0153ur m\u00e9tier. service : Ce package est d\u00e9di\u00e9 \u00e0 l'emploi de la technologie de traitement, en Jakarta EE il s'agit d' EJB .","title":"Organisation par technologie"},{"location":"java/packaging/","text":"Format binaire Java Format JAR Le format JAR ( J *ava AR chive ) pour les fichiers \u00e0 l'extension *.jar est le format le plus rependu dans le monde Java. Il s'agit simplement d'une archive type ZIP* contenant le code Java compil\u00e9 (fichier \u00e0 l'extension .class ). Par d\u00e9faut, il est utilis\u00e9 pour former des biblioth\u00e8ques logicielles pour d'autres applications. Variante ex\u00e9cutable Suivant les m\u00e9tadonn\u00e9es renseign\u00e9es lors de la compilation un fichier JAR peut se comporter comme un programme ex\u00e9cutable. Voici comment l'ex\u00e9cuter en ligne de commande: java -jar my-app.jar Variante EJB Pour les projets utilisant les technologies Jakarta EE , notamment la technologie EJB: Enterprise Java Bean , le format JAR est \u00e9galement utilis\u00e9, mais les m\u00e9tadonn\u00e9es sont diff\u00e9rentes. {{:dev:java:java_ejb_structure.gif| Structure EJB}} Source: Oracle Par exemple, on peut encore identifier la pr\u00e9sence du fichier ejb-jar.xml dans le code compil\u00e9. Format WAR Le format WAR pour W *eb application AR chive ou fichier portant l'extension *.war , est utilis\u00e9 g\u00e9n\u00e9ralement pour la conception d'application web en Java. Pour fonctionner, ce type de fichier doit \u00eatre d\u00e9ploy\u00e9 sur un serveur d'applications Java tel que Wildfly , Glassfish , Payara , WebLogic ou encore Tomcat*. {{:dev:java:java_war_structure.gif| Structure WAR}} Source: Oracle Dans ce type d'archive, on retrouve: * Les m\u00e9tadonn\u00e9es (fichiers XML ) * Le code Java compil\u00e9. * Les ressources web: JSP , JSPX , XHTML , HTML , CSS , JavaScript . * Les ressources statiques : images, polices d'\u00e9criture... * Les autres d\u00e9pendances logicielles sous forme de JAR dans un sous-dossier lib . Format EAR Il signifie E *nterprise AR chive pour les fichiers \u00e0 l'extension *.ear . Ce format est exclusif aux applications Jarkarta EE et il ne peut uniquement \u00eatre d\u00e9ploy\u00e9 sur des serveur d'applications supportant pleinement la plateforme Jakarta EE*. {{:dev:java:java_ear_structure.gif|Structure EAR}} Source: Oracle Cette archive est en r\u00e9alit\u00e9 un regroupement : De m\u00e9tadonn\u00e9es (fichier XML ) De modules EJB De modules WAR De modules RAR De modules client JAR Des autres d\u00e9pendances logicielles sous forme de JAR . Note Les archives RAR ( R esource Adapter AR chive) \u00e0 l'extension *.rar sont d'anciennes archives de l'\u00e9cosyst\u00e8me Java EE contenant des fichiers sp\u00e9cifiques \u00e0 un environnement ou \u00e0 une architecture. Ce type de module est en d\u00e9su\u00e9tude, de m\u00eame que les modules clients JAR . Philosophie de construction Dans un projet de type EAR chaque module \u00e0 des fonctions bien d\u00e9finies. Les modules EJB repr\u00e9sente la partie de traitement c\u00f4t\u00e9 serveur o\u00f9 le traitement m\u00e9tier est effectu\u00e9 ainsi que la sauvegarde en base de donn\u00e9es. En g\u00e9n\u00e9ral pour de grande application, on cr\u00e9e un module EJB par zone fonctionnelle. Les modules WAR repr\u00e9sente la partie client l\u00e9ger de l'application, il peut s'agit d'une application servant des pages web ou d'une application de type SOAP ou REST . On cr\u00e9e un module WAR par zone fonctionnelle et/ou par cat\u00e9gorie d'interface (interface web, REST, SOAP...). Exemple : Dans un site marchand, on peut imaginer la gestion de stock et la pr\u00e9paration d'une commande comme deux zones fonctionnelles distinctes. Ainsi, nous avons deux modules EJB pour le traitement m\u00e9tier et au moins deux modules WAR pour la partie cliente. (Je pr\u00e9cise au moins, car on pourrait imaginer pour un module EJB avoir une partie accessible \u00e0 travers des pages web et une autres \u00e0 travers une API REST , soit deux modules WAR ). Cela permet un d\u00e9coupage logiciel plus propre. \u00c0 l'avenir, il est d'autant plus simple de d\u00e9couper l'applicatif si l'on consid\u00e8re le d\u00e9coupage microservice .","title":"Format binaire"},{"location":"java/packaging/#format-binaire-java","text":"","title":"Format binaire Java"},{"location":"java/packaging/#format-jar","text":"Le format JAR ( J *ava AR chive ) pour les fichiers \u00e0 l'extension *.jar est le format le plus rependu dans le monde Java. Il s'agit simplement d'une archive type ZIP* contenant le code Java compil\u00e9 (fichier \u00e0 l'extension .class ). Par d\u00e9faut, il est utilis\u00e9 pour former des biblioth\u00e8ques logicielles pour d'autres applications.","title":"Format JAR"},{"location":"java/packaging/#variante-executable","text":"Suivant les m\u00e9tadonn\u00e9es renseign\u00e9es lors de la compilation un fichier JAR peut se comporter comme un programme ex\u00e9cutable. Voici comment l'ex\u00e9cuter en ligne de commande: java -jar my-app.jar","title":"Variante ex\u00e9cutable"},{"location":"java/packaging/#variante-ejb","text":"Pour les projets utilisant les technologies Jakarta EE , notamment la technologie EJB: Enterprise Java Bean , le format JAR est \u00e9galement utilis\u00e9, mais les m\u00e9tadonn\u00e9es sont diff\u00e9rentes. {{:dev:java:java_ejb_structure.gif| Structure EJB}} Source: Oracle Par exemple, on peut encore identifier la pr\u00e9sence du fichier ejb-jar.xml dans le code compil\u00e9.","title":"Variante EJB"},{"location":"java/packaging/#format-war","text":"Le format WAR pour W *eb application AR chive ou fichier portant l'extension *.war , est utilis\u00e9 g\u00e9n\u00e9ralement pour la conception d'application web en Java. Pour fonctionner, ce type de fichier doit \u00eatre d\u00e9ploy\u00e9 sur un serveur d'applications Java tel que Wildfly , Glassfish , Payara , WebLogic ou encore Tomcat*. {{:dev:java:java_war_structure.gif| Structure WAR}} Source: Oracle Dans ce type d'archive, on retrouve: * Les m\u00e9tadonn\u00e9es (fichiers XML ) * Le code Java compil\u00e9. * Les ressources web: JSP , JSPX , XHTML , HTML , CSS , JavaScript . * Les ressources statiques : images, polices d'\u00e9criture... * Les autres d\u00e9pendances logicielles sous forme de JAR dans un sous-dossier lib .","title":"Format WAR"},{"location":"java/packaging/#format-ear","text":"Il signifie E *nterprise AR chive pour les fichiers \u00e0 l'extension *.ear . Ce format est exclusif aux applications Jarkarta EE et il ne peut uniquement \u00eatre d\u00e9ploy\u00e9 sur des serveur d'applications supportant pleinement la plateforme Jakarta EE*. {{:dev:java:java_ear_structure.gif|Structure EAR}} Source: Oracle Cette archive est en r\u00e9alit\u00e9 un regroupement : De m\u00e9tadonn\u00e9es (fichier XML ) De modules EJB De modules WAR De modules RAR De modules client JAR Des autres d\u00e9pendances logicielles sous forme de JAR . Note Les archives RAR ( R esource Adapter AR chive) \u00e0 l'extension *.rar sont d'anciennes archives de l'\u00e9cosyst\u00e8me Java EE contenant des fichiers sp\u00e9cifiques \u00e0 un environnement ou \u00e0 une architecture. Ce type de module est en d\u00e9su\u00e9tude, de m\u00eame que les modules clients JAR .","title":"Format EAR"},{"location":"java/packaging/#philosophie-de-construction","text":"Dans un projet de type EAR chaque module \u00e0 des fonctions bien d\u00e9finies. Les modules EJB repr\u00e9sente la partie de traitement c\u00f4t\u00e9 serveur o\u00f9 le traitement m\u00e9tier est effectu\u00e9 ainsi que la sauvegarde en base de donn\u00e9es. En g\u00e9n\u00e9ral pour de grande application, on cr\u00e9e un module EJB par zone fonctionnelle. Les modules WAR repr\u00e9sente la partie client l\u00e9ger de l'application, il peut s'agit d'une application servant des pages web ou d'une application de type SOAP ou REST . On cr\u00e9e un module WAR par zone fonctionnelle et/ou par cat\u00e9gorie d'interface (interface web, REST, SOAP...). Exemple : Dans un site marchand, on peut imaginer la gestion de stock et la pr\u00e9paration d'une commande comme deux zones fonctionnelles distinctes. Ainsi, nous avons deux modules EJB pour le traitement m\u00e9tier et au moins deux modules WAR pour la partie cliente. (Je pr\u00e9cise au moins, car on pourrait imaginer pour un module EJB avoir une partie accessible \u00e0 travers des pages web et une autres \u00e0 travers une API REST , soit deux modules WAR ). Cela permet un d\u00e9coupage logiciel plus propre. \u00c0 l'avenir, il est d'autant plus simple de d\u00e9couper l'applicatif si l'on consid\u00e8re le d\u00e9coupage microservice .","title":"Philosophie de construction"},{"location":"java/platform/","text":"Plateforme Introduction La plateforme Java se d\u00e9cline en deux \u00e9ditions : * Java SE : Java Standard Edition * Java EE : Java Enterprise Edition Une \u00e9dition est un ensemble de biblioth\u00e8ques logicielles et d'outils int\u00e9gr\u00e9s \u00e0 la plateforme. Java SE est l'\u00e9dition contenue par d\u00e9faut lorsque vous installez Java que ce soit OracleJDK , OpenJDK ou encore AdoptOpenJDK . Java EE est l'\u00e9dition contenue dans les serveurs d'applications certifi\u00e9s Java EE . Exemple : Wildfly , Glassfish , Payara , WebLogic , etc... Le serveur Apache Tomcat n'est pas certifi\u00e9 car il n'impl\u00e9mente qu'une partie de la sp\u00e9cification Java EE, principalement les Servlet . C'est un choix assum\u00e9. Note Apr\u00e8s l'arriv\u00e9e de Java EE 8 , Oracle \u00e0 l'abandon de cette \u00e9dition. C'est d\u00e9sormais la Fondation Eclipse qui reprend ce projet sous le nom de de Jakarta EE . Afin d'effectuer la transition en douceur, la Fondation Eclipse a publi\u00e9e Jakarta EE 8 , une version interm\u00e9diaire pour le passage \u00e0 Java 11. Mais attendez-vous \u00e0 une perte de r\u00e9trocompatibilit\u00e9 avec Jakarta EE 9 . Composition des plateformes Vision globale Source: Wikip\u00e9dia L\u00e9gende: * JRE : Java Runtime Environment * Environnement minimal pour l'ex\u00e9cution de programme Java. * JRE Library * Ensemble de biblioth\u00e8ques logicielles standard. * JVM : Java Virtual Machine * Machine virtuelle permettant l'ex\u00e9cution du code compil\u00e9 Java et de d'autres langages bas\u00e9s sur la JVM . * JDK : Java Development Kit * Ensemble d'outil fournit avec une plateforme pour le d\u00e9veloppement. (Exemple: le compilateur) * JSR : Java Specification Requests * Ensemble de sp\u00e9cification normalis\u00e9 faisant \u00e9voluer la plateforme. Les JSR sont valid\u00e9s par une communaut\u00e9 ( JCP: Java Community Process ) avant d'int\u00e9grer une plateforme. * Java SE : Java Standard Edition * Plateforme de base de Java, il existe des variantes : avec ou sans JDK . * Java EE : Java Enterprise Edition * Plateforme d'entreprise Java, il existe des variantes: Web Profile , Full Profile ... * Java FX * Ensemble de biblioth\u00e8ques logicielles pour la cr\u00e9ation de client lourd, successeur de Swing . Java SE Source: Oracle Voici en d\u00e9tail le contenu de la plateforme Java SE 8 . Note En Java 1.8 , Java FX faisait partie int\u00e9grante de Java SE . A partir de Java 9 , Java FX est une plateforme ind\u00e9pendante. Java EE Source: Oracle Voici en d\u00e9tail le contenu de la plateforme Java EE 8 . Le contenu reste similaire pour Jakarta EE 8 . En bleu fonc\u00e9, les briques logicielles mise \u00e0 jour depuis Java EE 7 . En orange, les nouvelles briques logicielles ajout\u00e9es en Java EE 8 . D\u00e9tail de quelques technologies principalement utilis\u00e9es: Bean Validation Validation de donn\u00e9es \u00e0 l'aide d'annotations. JTA : Java Transaction API Technologie de gestion des transactions pour les base de donn\u00e9es. Servlet Technologie permettant la communication client-serveur \u00e0 travers de requ\u00eate et de r\u00e9ponse sur le r\u00e9seau, principalement utilis\u00e9 avec le protocole HTTP . CDI : Context Dependency Injection Technologie d'injection de d\u00e9pendance, elle g\u00e8re le cycle de vie des objets injectables. Permet \u00e9galement une approche \u00e9v\u00e9nementielle dans le code. EJB : Enterprise Java Bean Technologie utilis\u00e9e pour la logique de traitement. JSF : Java Server Faces Technologie de cr\u00e9ation de page web orient\u00e9 composant. JPA : Java Persistence API Technologie de persistance de donn\u00e9es pour les base de donn\u00e9es. JAX-RS Technologie pour la construction de service web de type REST . JSON-P Technologie pour la manipulation de fichier JSON . JAX-WS Technologie pour la construction de service web de type SOAP . JSP Ancienne technologie pour la construction de page web. WebSocket Technologie de communication bidirectionnelle client-serveur. JAXB Ancienne technologie pour le support du format XML . JSON-B Nouvelle technologie en compl\u00e9ment de JSON-P pour la conversion au format JSON \u00e0 l'aide d'annotation. Security Nouvelle technologie pour s\u00e9curiser une application Jakarta EE .","title":"Plateforme"},{"location":"java/platform/#plateforme","text":"","title":"Plateforme"},{"location":"java/platform/#introduction","text":"La plateforme Java se d\u00e9cline en deux \u00e9ditions : * Java SE : Java Standard Edition * Java EE : Java Enterprise Edition Une \u00e9dition est un ensemble de biblioth\u00e8ques logicielles et d'outils int\u00e9gr\u00e9s \u00e0 la plateforme. Java SE est l'\u00e9dition contenue par d\u00e9faut lorsque vous installez Java que ce soit OracleJDK , OpenJDK ou encore AdoptOpenJDK . Java EE est l'\u00e9dition contenue dans les serveurs d'applications certifi\u00e9s Java EE . Exemple : Wildfly , Glassfish , Payara , WebLogic , etc... Le serveur Apache Tomcat n'est pas certifi\u00e9 car il n'impl\u00e9mente qu'une partie de la sp\u00e9cification Java EE, principalement les Servlet . C'est un choix assum\u00e9. Note Apr\u00e8s l'arriv\u00e9e de Java EE 8 , Oracle \u00e0 l'abandon de cette \u00e9dition. C'est d\u00e9sormais la Fondation Eclipse qui reprend ce projet sous le nom de de Jakarta EE . Afin d'effectuer la transition en douceur, la Fondation Eclipse a publi\u00e9e Jakarta EE 8 , une version interm\u00e9diaire pour le passage \u00e0 Java 11. Mais attendez-vous \u00e0 une perte de r\u00e9trocompatibilit\u00e9 avec Jakarta EE 9 .","title":"Introduction"},{"location":"java/platform/#composition-des-plateformes","text":"","title":"Composition des plateformes"},{"location":"java/platform/#vision-globale","text":"Source: Wikip\u00e9dia L\u00e9gende: * JRE : Java Runtime Environment * Environnement minimal pour l'ex\u00e9cution de programme Java. * JRE Library * Ensemble de biblioth\u00e8ques logicielles standard. * JVM : Java Virtual Machine * Machine virtuelle permettant l'ex\u00e9cution du code compil\u00e9 Java et de d'autres langages bas\u00e9s sur la JVM . * JDK : Java Development Kit * Ensemble d'outil fournit avec une plateforme pour le d\u00e9veloppement. (Exemple: le compilateur) * JSR : Java Specification Requests * Ensemble de sp\u00e9cification normalis\u00e9 faisant \u00e9voluer la plateforme. Les JSR sont valid\u00e9s par une communaut\u00e9 ( JCP: Java Community Process ) avant d'int\u00e9grer une plateforme. * Java SE : Java Standard Edition * Plateforme de base de Java, il existe des variantes : avec ou sans JDK . * Java EE : Java Enterprise Edition * Plateforme d'entreprise Java, il existe des variantes: Web Profile , Full Profile ... * Java FX * Ensemble de biblioth\u00e8ques logicielles pour la cr\u00e9ation de client lourd, successeur de Swing .","title":"Vision globale"},{"location":"java/platform/#java-se","text":"Source: Oracle Voici en d\u00e9tail le contenu de la plateforme Java SE 8 . Note En Java 1.8 , Java FX faisait partie int\u00e9grante de Java SE . A partir de Java 9 , Java FX est une plateforme ind\u00e9pendante.","title":"Java SE"},{"location":"java/platform/#java-ee","text":"Source: Oracle Voici en d\u00e9tail le contenu de la plateforme Java EE 8 . Le contenu reste similaire pour Jakarta EE 8 . En bleu fonc\u00e9, les briques logicielles mise \u00e0 jour depuis Java EE 7 . En orange, les nouvelles briques logicielles ajout\u00e9es en Java EE 8 . D\u00e9tail de quelques technologies principalement utilis\u00e9es: Bean Validation Validation de donn\u00e9es \u00e0 l'aide d'annotations. JTA : Java Transaction API Technologie de gestion des transactions pour les base de donn\u00e9es. Servlet Technologie permettant la communication client-serveur \u00e0 travers de requ\u00eate et de r\u00e9ponse sur le r\u00e9seau, principalement utilis\u00e9 avec le protocole HTTP . CDI : Context Dependency Injection Technologie d'injection de d\u00e9pendance, elle g\u00e8re le cycle de vie des objets injectables. Permet \u00e9galement une approche \u00e9v\u00e9nementielle dans le code. EJB : Enterprise Java Bean Technologie utilis\u00e9e pour la logique de traitement. JSF : Java Server Faces Technologie de cr\u00e9ation de page web orient\u00e9 composant. JPA : Java Persistence API Technologie de persistance de donn\u00e9es pour les base de donn\u00e9es. JAX-RS Technologie pour la construction de service web de type REST . JSON-P Technologie pour la manipulation de fichier JSON . JAX-WS Technologie pour la construction de service web de type SOAP . JSP Ancienne technologie pour la construction de page web. WebSocket Technologie de communication bidirectionnelle client-serveur. JAXB Ancienne technologie pour le support du format XML . JSON-B Nouvelle technologie en compl\u00e9ment de JSON-P pour la conversion au format JSON \u00e0 l'aide d'annotation. Security Nouvelle technologie pour s\u00e9curiser une application Jakarta EE .","title":"Java EE"},{"location":"java/polymorphism/","text":"Polymorphisme Introduction Le polymorphisme est un concept de la programmation orient\u00e9e objet . C'est la capacit\u00e9 d'un objet d'opter pour le type d'un de ces parents sans changer son comportement. Il permet \u00e0 une instance de : Changer de type par un type parent. \u00catre vues et manipul\u00e9es par les autres classes comme un type parent. Conserver le comportement initial de la classe malgr\u00e9 le changement de type. Faire du faible couplage Note La notion de hi\u00e9rarchie de classe doit \u00eatre respect\u00e9e ! Cas d'usage Consid\u00e9rons les classes suivantes : package fr.zelmoacademy.sample; import java.time.LocalDate; import java.time.Period; public abstract class Pet { protected String name; protected Float size; protected Float weight; protected LocalDate birthDate; protected Pet() { } public abstract void talk(); public void sleep() { System.out.println(\"...zzz...\"); } public final Period getAge(){ return Period.between(LocalDate.now(), birthDate); } } package fr.zelmoacademy.sample; public class Cat extends Pet { public Cat() { } @Override public void talk() { System.out.println(\"Meow\"); } @Override public void sleep() { System.out.println(\"Purrr\"); } public void huntMice() { // ... } } package fr.zelmoacademy.sample; public class Dog extends Pet { public Dog() { } @Override public void talk() { System.out.println(\"Woof\"); } @Override public void sleep() { super.sleep(); // Combine l'appel de la classe parent System.out.println(\"Zzz\"); // ET l'appel de la classe enfant. } //> Sortie Console: // ...zzz... // Zzz public void sniff() { // ... } } Mise en \u0153uvre D\u00e9claration classique : Cat tom = new Cat(); // tom est de type 'Cat'. // Toutes les m\u00e9thodes de la classe 'Cat' sont accessibles. Dog spike = new Dog(); // spike est de type 'Dog'. // Toutes les m\u00e9thodes de la classe 'Dog' sont accessibles. // Variante en Java 10 avec l'inf\u00e9rence de type: var tom = new Cat(); var spike = new Dog(); D\u00e9claration polymorphique : Pet tom = new Cat(); // tom est de type 'Cat'. // Uniquement les m\u00e9thodes de la classe 'Pet' sont accessibles. Pet spike = new Dog(); // tom est de type 'Dog'. // Uniquement les m\u00e9thodes de la classe 'Pet' sont accessibles. Faible couplage : // Cette m\u00e9thode peut prendre en param\u00e8tre des objets de type 'Pet' ou enfant de 'Pet'. // C'est \u00e0 dire 'Cat' ou 'Dog' public void ownerAskPet(Pet anyPet){ anyPet.talk(); } Cette m\u00e9thode veut pouvoir demander \u00e0 un animal de compagnie de parler, mais quelque soit l'animal en question. De plus, la r\u00e9ponse de l'animal se doit d'\u00eatre sp\u00e9cifique au type r\u00e9el. Cat tom = new Cat(); ownerAskPet(tom); // Sortie console: 'Meow' Dog spike = new Dog(); ownerAskPet(spike); // Sortie console: 'Woof' // Variante Java 10 var sylvestre = new Cat(); ownerAskPet(sylvestre); // Sortie console: 'Meow' Transtypage Le polymorphisme permet de naturellement type une classe dans sa hi\u00e9rarchie montante. Le transtypage permet de forcer le type d'un objet vers un objet. Il faut \u00eatre prudent lors de son usage car le compilateur Java n'est pas en mesure de v\u00e9rifier le typage. Si le typage est faux, \u00e0 l'ex\u00e9cution du programme vous aurez une erreur de type : 'java.lang.ClassCastException'. Note En Java le transtypage est aussi connu sous le nom de //cast// . Pet tom = new Cat(); // tom est en r\u00e9alit\u00e9 de type 'Cat'. tom.talk(); // M\u00e9thode existante dans la classe 'Pet' OK. tom.huntMice(); ^^^^^^^^^^------- // Erreur de compilation: // m\u00e9thode inexistante dans la classe 'Pet'. // transtypage: Cat tomCat = (Cat) tom; tomCat.huntMice(); // M\u00e9thode existante dans la classe 'Cat' OK. // transtypage: Dog tomDog = (Dog) tom; ^^^----- // Erreur d'ex\u00e9cution: 'java.lang.ClassCastException' // tom n'a pas de lien avec la classe 'Dog'. Note Le transtypage est du polymorphisme non naturel ! Soyez tr\u00e8s prudent lors de son usage, si possible \u00e9viter de l'utiliser abusivement.","title":"Polymorphisme"},{"location":"java/polymorphism/#polymorphisme","text":"","title":"Polymorphisme"},{"location":"java/polymorphism/#introduction","text":"Le polymorphisme est un concept de la programmation orient\u00e9e objet . C'est la capacit\u00e9 d'un objet d'opter pour le type d'un de ces parents sans changer son comportement. Il permet \u00e0 une instance de : Changer de type par un type parent. \u00catre vues et manipul\u00e9es par les autres classes comme un type parent. Conserver le comportement initial de la classe malgr\u00e9 le changement de type. Faire du faible couplage Note La notion de hi\u00e9rarchie de classe doit \u00eatre respect\u00e9e !","title":"Introduction"},{"location":"java/polymorphism/#cas-dusage","text":"Consid\u00e9rons les classes suivantes : package fr.zelmoacademy.sample; import java.time.LocalDate; import java.time.Period; public abstract class Pet { protected String name; protected Float size; protected Float weight; protected LocalDate birthDate; protected Pet() { } public abstract void talk(); public void sleep() { System.out.println(\"...zzz...\"); } public final Period getAge(){ return Period.between(LocalDate.now(), birthDate); } } package fr.zelmoacademy.sample; public class Cat extends Pet { public Cat() { } @Override public void talk() { System.out.println(\"Meow\"); } @Override public void sleep() { System.out.println(\"Purrr\"); } public void huntMice() { // ... } } package fr.zelmoacademy.sample; public class Dog extends Pet { public Dog() { } @Override public void talk() { System.out.println(\"Woof\"); } @Override public void sleep() { super.sleep(); // Combine l'appel de la classe parent System.out.println(\"Zzz\"); // ET l'appel de la classe enfant. } //> Sortie Console: // ...zzz... // Zzz public void sniff() { // ... } }","title":"Cas d'usage"},{"location":"java/polymorphism/#mise-en-uvre","text":"D\u00e9claration classique : Cat tom = new Cat(); // tom est de type 'Cat'. // Toutes les m\u00e9thodes de la classe 'Cat' sont accessibles. Dog spike = new Dog(); // spike est de type 'Dog'. // Toutes les m\u00e9thodes de la classe 'Dog' sont accessibles. // Variante en Java 10 avec l'inf\u00e9rence de type: var tom = new Cat(); var spike = new Dog(); D\u00e9claration polymorphique : Pet tom = new Cat(); // tom est de type 'Cat'. // Uniquement les m\u00e9thodes de la classe 'Pet' sont accessibles. Pet spike = new Dog(); // tom est de type 'Dog'. // Uniquement les m\u00e9thodes de la classe 'Pet' sont accessibles. Faible couplage : // Cette m\u00e9thode peut prendre en param\u00e8tre des objets de type 'Pet' ou enfant de 'Pet'. // C'est \u00e0 dire 'Cat' ou 'Dog' public void ownerAskPet(Pet anyPet){ anyPet.talk(); } Cette m\u00e9thode veut pouvoir demander \u00e0 un animal de compagnie de parler, mais quelque soit l'animal en question. De plus, la r\u00e9ponse de l'animal se doit d'\u00eatre sp\u00e9cifique au type r\u00e9el. Cat tom = new Cat(); ownerAskPet(tom); // Sortie console: 'Meow' Dog spike = new Dog(); ownerAskPet(spike); // Sortie console: 'Woof' // Variante Java 10 var sylvestre = new Cat(); ownerAskPet(sylvestre); // Sortie console: 'Meow'","title":"Mise en \u0153uvre"},{"location":"java/polymorphism/#transtypage","text":"Le polymorphisme permet de naturellement type une classe dans sa hi\u00e9rarchie montante. Le transtypage permet de forcer le type d'un objet vers un objet. Il faut \u00eatre prudent lors de son usage car le compilateur Java n'est pas en mesure de v\u00e9rifier le typage. Si le typage est faux, \u00e0 l'ex\u00e9cution du programme vous aurez une erreur de type : 'java.lang.ClassCastException'. Note En Java le transtypage est aussi connu sous le nom de //cast// . Pet tom = new Cat(); // tom est en r\u00e9alit\u00e9 de type 'Cat'. tom.talk(); // M\u00e9thode existante dans la classe 'Pet' OK. tom.huntMice(); ^^^^^^^^^^------- // Erreur de compilation: // m\u00e9thode inexistante dans la classe 'Pet'. // transtypage: Cat tomCat = (Cat) tom; tomCat.huntMice(); // M\u00e9thode existante dans la classe 'Cat' OK. // transtypage: Dog tomDog = (Dog) tom; ^^^----- // Erreur d'ex\u00e9cution: 'java.lang.ClassCastException' // tom n'a pas de lien avec la classe 'Dog'. Note Le transtypage est du polymorphisme non naturel ! Soyez tr\u00e8s prudent lors de son usage, si possible \u00e9viter de l'utiliser abusivement.","title":"Transtypage"},{"location":"java/project_crud/","text":"Projet de synth\u00e8se Introduction L'objectif de cet article est de r\u00e9aliser une application REST ( RE presentational S tate T ransfer) en Java avec les technologies Jakarta EE 8 . Le format d'\u00e9change de donn\u00e9e sera JSON ( J ava S cript O bject N otation) . Il s\u2019agira d'une simple application CRUD * ( C reate R ead U pade D* elete) . Sans logique m\u00e9tier particulier. Nom de code : Dyna Une application dynamique et g\u00e9n\u00e9rique pour les op\u00e9rations de CRUD . Pr\u00e9paratif Pour r\u00e9aliser ce projet, nous utiliserons : Java 11 Payara Server 5.X Maven 3.6.X Pas besoin de biblioth\u00e8que logicielle suppl\u00e9mentaire. Arborescence du projet : + fr.zelmoacademy.dyna + common - controller - persistence - service - util - feature1 - feature2 - ... L\u00e9gende: * fr.zelmoacademy.dyna : package racine du projet. * common : Partie commune de tout le projet (c'est ici que nous travaillerons). * controller : Partie contr\u00f4leur REST . * persistence : Partie mod\u00e8le et persistance en base de donn\u00e9es. * service : Partie traitement applicatif. * util / Classe utilitaire. * feature1 , feature2 , ... : Partie sp\u00e9cifique \u00e0 une zone fonctionnelle. Note Afin de simplifier la structure du projet, l'application sera une archive de type WAR . Mais rien ne vous emp\u00eache d'utiliser le format EAR . Couche de persistance Entit\u00e9 Pour r\u00e9duire la quantit\u00e9 de ligne de code, les entit\u00e9s persistances seront manipul\u00e9es dans toutes les couches de notre architecture logicielle. Pour cela nous utiliserons les annotations Jakarta EE pour : * R\u00e9aliser la liaison avec la base donn\u00e9es (avec JPA . * R\u00e9aliser la conversion au format JSON (avec JSON-B ). * Porter les contraintes de validation des attributs (avec BeanValidation ). Afin de regrouper nos entit\u00e9s sous une m\u00eame hi\u00e9rarchie de classe, nous codons cette interface commune \u00e0 toutes les entit\u00e9s: package fr.zelmoacademy.dyna.common.persistence; // Utilisation de la g\u00e9n\u00e9ricit\u00e9 pour typer la clef primaire. public interface Identifiable<K> { // V\u00e9rifie l'\u00e9tat de la clef primaire. // Si la valeur n'est pas d\u00e9finie, elle sera alors g\u00e9n\u00e9r\u00e9e. // Sera utile plus tard pour diff\u00e9rencier une cr\u00e9ation d'une mise \u00e0 jour. void checkId(); // Simple accesseur & mutateur de la clef primaire. K getId(); void setId(K id); } Pour plus de facilit\u00e9, voici un exemple de classe m\u00e8re afin de factoriser du code : package fr.zelmoacademy.dyna.common.persistence; import ... // JSON-B: Trier les attributs par ordre alphab\u00e9tique @JsonbPropertyOrder(PropertyOrderStrategy.LEXICOGRAPHICAL) // JPA: Indique que les attributs de cette classe seront fusionn\u00e9s dans la table SQL enfant. @MappedSuperclass // Impl\u00e9menter 'Identifiable' avec une clef primaire de type 'UUID'. public abstract class AbstractEntity implements Identifiable<UUID>, Serializable { // Num\u00e9ro de s\u00e9rie pour respecter le m\u00e9canisme de s\u00e9rialisation. private static final long serialVersionUID = 1L; // BeanValidation: Contrainte non nulle. @NotNull // JSON-B: Nom et contrainte de l'attribut pour le format JSON. @JsonbProperty(value = \"id\", nillable = true) // JPA: Clef primaire @Id // JPA: Nom et contrainte de la colonne en base de donn\u00e9es. // /!\\ Ce type n'est pas g\u00e9r\u00e9 nativement par JPA, on explicite le type SQL 'VARCHAR(36)'. @Column(name = \"id\", nullable = false, unique = true, columnDefinition = \"VARCHAR(36)\") protected UUID id; // BeanValidation: Contrainte non nulle. @NotNull // JSON-B: Nom et contrainte de l'attribut pour le format JSON. @JsonbProperty(value = \"version\", nillable = true) // JPA: Num\u00e9ro de version du tuple en base de donn\u00e9es, s'incr\u00e9mente \u00e0 chaque modification. @Version // JPA: Nom et contrainte de la colonne en base de donn\u00e9es. @Column(name = \"version\", nullable = false) protected Long version; // Java Bean: Constructeur par d\u00e9faut. protected AbstractEntity() { this.id = UUID.randomUUID(); this.version = 0L; } // Surchage des m\u00e9thodes: 'equals', 'hashCode', 'toString' // ... @Override public void checkId(){ // Dans notre cas, c'est l'application qui assure // l'int\u00e9grit\u00e9 de la clef primaire. if(Objects.isNull(id){ id = UUID.randomUUID(); } if(Objects.isNull(version){ version = 0L; } } // Accesseurs & Mutateurs // ... } Exemple d'entit\u00e9 concr\u00e8te : package fr.zelmoacademy.dyna.customer; import ...; // CDI: Cette classe est injectable @Dependent // JSON-B: Trier les attributs par ordre alphab\u00e9tique @JsonbPropertyOrder(PropertyOrderStrategy.LEXICOGRAPHICAL) // JPA: Entit\u00e9 persistante li\u00e9e \u00e0 la table 'customer' en base de donn\u00e9es. @Entity @Table(name = \"customer\") public class Customer extends AbstractEntity { private static final long serialVersionUID = 1L; // BeanValidation: Contrainte non vide. @NotBlank // JSON-B: Nom et contrainte de l'attribut pour le format JSON. @JsonbProperty(value = \"givenName\", nillable = false) // JPA: Nom et contrainte de la colonne en base de donn\u00e9es. @Column(name = \"given_name\", nullable = false) private String givenName; // BeanValidation: Contrainte non vide. @NotBlank // JSON-B: Nom et contrainte de l'attribut pour le format JSON. @JsonbProperty(value = \"familyName\", nillable = false) // JPA: Nom et contrainte de la colonne en base de donn\u00e9es. @Column(name = \"family_name\", nullable = false) private String familyName; // BeanValidation: Contrainte, format adresse de courriel et non vide. @Email @NotBlank // JSON-B: Nom et contrainte de l'attribut pour le format JSON. @JsonbProperty(value = \"email\", nillable = false) // JPA: Nom et contrainte de la colonne en base de donn\u00e9es. @Column(name = \"email\", nullable = false, unique = true) private String email; public Customer() { } // Surchage des m\u00e9thodes: 'equals', 'hashCode', 'toString' // ... // Accesseurs & Mutateurs // ... } Convertisseur d'attribut Le type java.util.UUID n'est pas g\u00e9n\u00e9r\u00e9 nativement par JPA . Il est n\u00e9cessaire de coder un convertisseur de type. Dans notre code, on convertira le type java.util.UUID en java.lang.String . package fr.zelmoacademy.dyna.common.persistence; import ...; // Applique le convertisseur automatiquent pour tous les attributs JPA de type 'java.util.UUID'. @Converter(autoApply = true) public class UUIDConverter implements AttributeConverter<UUID, String> { public static final String COLUMN_DEFINITION = \"VARCHAR(36)\"; public UUIDConverter() { } // Convertir un attribut en colonne de base de donn\u00e9es. @Override public String convertToDatabaseColumn(UUID attribute) { String column; if (Objects.nonNull(attribute)) { column = attribute.toString(); } else { column = null; } return column; } // Convertir une colonne de base de donn\u00e9es en attribut. @Override public UUID convertToEntityAttribute(String column) { UUID attribute; if (Objects.nonNull(column)) { attribute = UUID.fromString(column); } else { attribute = null; } return attribute; } } Alignement CDI La technologie CDI ( C ontext D ependency I njection) est une technologie qui prend de l'ampleur dans Jakarta EE . A ce titre nous pouvons unifier les injections de d\u00e9pendance \u00e0 travers CDI. package fr.zelmoacademy.dyna.common.persistence; import ...; // Cette classe est initialis\u00e9e au d\u00e9marrage de l'application. @ApplicationScoped public class PersistenceResource { // Gestionnaire d'entit\u00e9 injectable avec CDI @Produces @PersistenceContext private EntityManager em; public PersistenceResource() { } } Gr\u00e2ce \u00e0 cette classe vous pouvez utiliser l'annotation @Inject sur un attribut de type javax.persistence.EntityManager . Entrep\u00f4t package fr.zelmoacademy.dyna.common.persistence; import ...; // Entrep\u00f4t de donn\u00e9es g\u00e9n\u00e9rique & polymorphique // Le pattern 'Repository/DAO' doit \u00e0 l'usage avoir le m\u00eame comportement qu'une 'Collection/List' en Java. // Comme cette classe s'adapte \u00e0 la plupart des entit\u00e9s persistantes, les types manipul\u00e9s seront donc // polymorph\u00e9 avec 'Identifiable' afin d\u2019assurer un minimum de typage. // Cette classe est injectable avec CDI. @Dependent public class GenericDAO implements Serializable { // Num\u00e9ro de s\u00e9rie pour respecter la s\u00e9rialisation. private static final long serialVersionUID = 1L; // JPA: Gestionnaire d'entit\u00e9 @Inject private transient EntityManager em; public GenericDAO() { } // R\u00e9cup\u00e9rer le nombre d'occurrence en base de donn\u00e9es pour une entit\u00e9 donn\u00e9e. public Long size(final Class<? extends Identifiable<?>> entityClass) { // SQL: // SELECT count(t.id) FROM table t; var builder = em.getCriteriaBuilder(); var query = builder.createQuery(Long.class); var root = query.from(entityClass); query.select(builder.count(root)); return em.createQuery(query).getSingleResult(); } // Indique si la table associ\u00e9e \u00e0 une entit\u00e9 est vide. public boolean isEmpty(final Class<? extends Identifiable<?>> entityClass) { return size(entityClass) == 0L; } // V\u00e9rifier d'une entit\u00e9 existe d\u00e9j\u00e0 en base de donn\u00e9es. public boolean contains(final Identifiable<?> entity) { var entityClass = entity.getClass(); boolean exists; if (em.contains(entity)) { // V\u00e9rification de l\u2019existence de l'entit\u00e9 dans le contexte de persistance. // (plus rapide qu'une requ\u00eate) exists = true; } else { // Sinon // Requ\u00eater en base de donn\u00e9es. // SQL: // SELECT count(t.id) FROM table t WHERE t.id = ?; var builder = em.getCriteriaBuilder(); var query = builder.createQuery(Long.class); var root = query.from(entityClass); query.select(builder.count(root)); var idTypeName = getIdentifierTypeName(entity); var predicate = builder.equal(root.get(idTypeName), entity.getId()); query.where(predicate); exists = em.createQuery(query).getSingleResult() == 1L; } return exists; } // Sauvegarder une entit\u00e9 // Si elle existe d\u00e9j\u00e0, la mettre \u00e0 jour en base de donn\u00e9es // Sinon l'ins\u00e9rer en base de donn\u00e9es. public Identifiable<?> add(final Identifiable<?> entity) { Identifiable<?> mangedEntity; if (contains(entity)) { // Mettre \u00e0 jour mangedEntity = em.merge(entity); } else { // Ins\u00e9rer en base de donn\u00e9es. em.persist(entity); mangedEntity = entity; } return mangedEntity; } // Supprimer une entit\u00e9 // SQL: // DELETE FROM table t WHERE t.id = ?; public void remove(final Identifiable<?> entity) { var entityClass = entity.getClass(); var id = getIdentifier(entity); var attachedEntity = em.getReference(entityClass, id); em.remove(attachedEntity); CDI.current().destroy(attachedEntity); } // Rechercher toutes les entit\u00e9s d'un type donn\u00e9: // /!\\ Peut remonter beaucoup d'objet et saturer la m\u00e9moire ! // SELECT t.col1, t.col2, t.col3, ... FROM table t; public List<? extends Identifiable<?>> get(final Class<? extends Identifiable<?>> entityClass) { var builder = em.getCriteriaBuilder(); var query = builder.createQuery(entityClass); return em .createQuery(query) .getResultList(); } // Rechercher une entit\u00e9 d'un type donn\u00e9 en fonction de son identifiant. public Optional<Identifiable<?>> get(final Class<? extends Identifiable<?>> entityClass, final Object id) { // Lecture dans le cache de persistance. var entity = em.find(entityClass, id); return Optional.ofNullable(entity); } // M\u00e9thode interne: // R\u00e9cup\u00e9rer dynamiquement la valeur de la clef primaire. private <K> K getIdentifier(final Identifiable<K> entity) { return (K) em .getEntityManagerFactory() .getPersistenceUnitUtil() .getIdentifier(entity); } // M\u00e9thode interne: // R\u00e9cup\u00e9rer dynamiquement le nom de l'attribut de la clef primaire. private String getIdentifierTypeName(final Identifiable<?> entity) { var entityClass = entity.getClass(); var id = getIdentifier(entity); var idClass = id.getClass(); return em .getMetamodel() .entity(entityClass) .getId(idClass) .getName(); } } Couche de services Le service m\u00e9tier ne poss\u00e8de pas de logique particuli\u00e8re. Son travail consiste principalement \u00e0 de la d\u00e9l\u00e9gation de m\u00e9thode. package fr.zelmoacademy.dyna.common.service; import ...; // Classe de service g\u00e9n\u00e9rique pour les op\u00e9rations de CRUD // Pas de logique particuli\u00e8re. // Simple appel de la DAO. // EJB: Indique que cette classe est sans \u00e9tat. @Stateless @LocalBean public class CommonService implements Serializable { // Num\u00e9ro de s\u00e9rie. private static final long serialVersionUID = 1L; // CDI: Injection de l'entrep\u00f4t de donn\u00e9e g\u00e9n\u00e9rique. @Inject private GenericDAO dao; // Java Bean: Constructeur par d\u00e9faut. public CommonService() { } // JTA:Java Transaction API // Gestionnaire de transaction // Par d\u00e9faut le EJB g\u00e8rent automatiquement les transactions // Mais dans de rare cas, il peut \u00eatre n\u00e9cessaire de de d\u00e9finir ce comportement soit-m\u00eame // JTA: Indique que cette m\u00e9thode requiert une nouvelle transaction. // Exemple: @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW) public void save(final Identifiable<?> entity) { // Si la clef primaire n'est pas d\u00e9finie, alors elle est g\u00e9n\u00e9r\u00e9e // Permet de distinguer la cr\u00e9ation d'une mise \u00e0 jour entity.checkId(); dao.add(entity); } // JTA: Indique que cette m\u00e9thode requiert une transaction. // Exemple: @TransactionAttribute(TransactionAttributeType.REQUIRED) public void remove(final Identifiable<?> entity) { dao.remove(entity); } // JTA: Indique que cette m\u00e9thode n'est pas besoin de transaction (lecture seule en base de donn\u00e9es) // Exemple: @TransactionAttribute(TransactionAttributeType.NEVER) public Optional<? extends Identifiable<?>> findById( final Class<? extends Identifiable<?>> entityClass, final Object id) { return dao.get(entityClass, id); } // JTA: Indique que cette m\u00e9thode n'est pas besoin de transaction (lecture seule en base de donn\u00e9es) // Exemple: @TransactionAttribute(TransactionAttributeType.NEVER) public List<? extends Identifiable<?>> find(final Class<? extends Identifiable<?>> entityClass) { return dao.get(entityClass); } } Variante CDI Variante de cette classe mais avec la technologie CDI . package fr.zelmoacademy.dyna.common.service; import ...; // Classe de service g\u00e9n\u00e9rique pour les op\u00e9rations de CRUD // Pas de logique particuli\u00e8re. // Simple appel de la DAO. // CDI: Instance charge au d\u00e9marrage de l'application et dans un r\u00e9gime transactionnel @ApplicationScoped @Transactional public class CommonService { // CDI: Injection de l'entrep\u00f4t de donn\u00e9e g\u00e9n\u00e9rique. @Inject private GenericDAO dao; // Java Bean: Constructeur par d\u00e9faut. public CommonService() { } // JTA:Java Transaction API // Gestionnaire de transaction // Par d\u00e9faut le CDI NE g\u00e8rent PAS automatiquement les transactions // Il est n\u00e9cessaire d'ajouter l'annotation @Transactional pour avoir un comportement // similaire aux EJB. // Dans de rare cas, il peut \u00eatre n\u00e9cessaire de de d\u00e9finir ce comportement soit-m\u00eame // Pour cela, il suffit de porter l'annotation @Transactional sur les m\u00e9thodes. // Exiger une nouvelle transaction pour m\u00e9thode. // M\u00eame logique pour EJB, seule l'annotation diff\u00e8re. // Exemple: @Transactional(Transactional.TxType.REQUIRES_NEW) public void save(final Identifiable<?> entity) { ... } // Autres m\u00e9thodes // ... } Note Effectivement, les EJB ne sont plus aussi indispensable qu'avant. Cette nouvelle \u00e9criture est valable depuis Java EE 7 . Source: [[https://blogs.oracle.com/theaquarium/jta-12-its-not-your-grandfathers-transactions-anymore | Blog Oracle]] Couche de contr\u00f4le Entit\u00e9 dynamique Nous allons mettre en \u0153uvre une \u00e9num\u00e9ration qui va porter en lui toute la sp\u00e9cificit\u00e9 de notre CRUD . Il arrive un stade o\u00f9 on ne peut plus \u00eatre g\u00e9n\u00e9rique, afin de simplifier le code aux maximum, cette partie sp\u00e9cifique va se limiter \u00e0 une seule classe. package fr.zelmoacademy.dyna; import ...; public enum DynamicEntity { // Exemple CUSTOMER(\"customer\", Customer.class, UUID::fromString); // Nom REST de l'entit\u00e9 cible pour le CRUD. // Ce nom est celui qui apparait dans l'URL. private final String name; // Type Java de l'entit\u00e9 private final Class<? extends Identifiable<?>> entityClass; // Fonction g\u00e9n\u00e9rique de conversion de la clef primaire // Depuis l'API, il arrive sous le type 'String' // cette fonction permet de le convertir sous un autre type // par exemple 'UUID' (voir exemple) private final Function<String, Object> identifierConverter; DynamicEntity( final String name, final Class<? extends Identifiable<?>> entityClass, final Function<String, Object> identifierConverter) { this.name = name; this.entityClass = entityClass; this.identifierConverter = identifierConverter; } // A partir du nom de l'entit\u00e9 // Rechercher la valeur de l'enum\u00e9ration correspondante. public static Optional<DynamicEntity> fromName(final String name) { return Stream .of(DynamicEntity.values()) .filter(e -> Objects.equals(e.name, name)) .findFirst(); } // Convertir une clef primaire de type 'String' // en autre autre type (polymorph\u00e9 en 'Object') public Object convertAsIdentifier(final String id) { return identifierConverter.apply(id); } // Accesseurs public String getName() { return name; } public Class<? extends Identifiable<?>> getEntityClass() { return entityClass; } } Note A pr\u00e9sent, lorsque le d\u00e9veloppeur souhaite ajouter une entit\u00e9 dans le CRUD , il suffira d'ajouter une entr\u00e9e dans cette \u00e9num\u00e9ration. Exemple: CUSTOMER(\"customer\", Customer.class, UUID::fromString) . Convertisseur dynamique Depuis notre API pour \u00eatre g\u00e9n\u00e9rique, nous recevons les donn\u00e9es sous forme de texte, sous java.lang.String en Java. Mais pour que l'application fonctionne correctement, nous avons besoin de convertir ces donn\u00e9es dans les bons types. Bien entendu, les types r\u00e9els seront polymorph\u00e9 en type abstrait pour conserver la g\u00e9n\u00e9ricit\u00e9. package fr.zelmoacademy.dyna.common.controller; import ...; public final class DynamicEntityMapper { // Constructeur interne. // Pas d'instanciation. private DynamicEntityMapper() { throw new UnsupportedOperationException(\"Instance not allowed\"); } // Convertir un 'String JSON' en entit\u00e9 (polymorph\u00e9 en 'Identifiable') // Si le type n'existe pas, une exception sera lev\u00e9e. public static Identifiable<?> mapToEntity(final String type, final String jsonEntity) { return DynamicEntity .fromName(type) .map(DynamicEntity::getEntityClass) .map(e -> JsonbBuilder.create().fromJson(jsonEntity, e)) .orElseThrow(() -> new WebApplicationException(\"Invalid entity\")); } // Convertir le nom du type en la classe Java de l'entit\u00e9. // Si le type n'existe pas, une exception sera lev\u00e9e. public static Class<? extends Identifiable<?>> mapToEntityClass(final String type) { return DynamicEntity .fromName(type) .map(DynamicEntity::getEntityClass) .orElseThrow(() -> new WebApplicationException(\"Invalid entity\")); } // Convertir un 'String' de la clef primaire en un autre type // en fonction du nom du type d'entit\u00e9. // Si le type n'existe pas, une exception sera lev\u00e9e. public static Object mapToEntityId(final String type, final String id) { return DynamicEntity .fromName(type) .map(e -> e.convertAsIdentifier(id)) .orElseThrow(() -> new WebApplicationException(\"Invalid entity\")); } } Contr\u00f4leur Pour utiliser les contr\u00f4leurs REST en Jakarta EE, une simple classe de configuration est n\u00e9cessaire: package fr.zelmoacademy.dyna.common.controller; import ...; // JAXRS: Chemin racine de toute l'API. @ApplicationPath(\"api\") public class RESTConfiguration extends Application { public RESTConfiguration() { } // RAS // Tout se configure avec les annotations. } Enfin, voici le contr\u00f4leur unique pour toutes les op\u00e9rations de CRUD . package fr.zelmoacademy.dyna.common.controller; import ...; // Cette classe est injectable // La dur\u00e9e de vie de l'instance est celui d'une requ\u00eate HTTP. @RequestScoped // Chemin de base du contr\u00f4leur @Path(\"v1/entity\") // Indique que le contr\u00f4leur produit et consomme du JSON. @Produces(MediaType.APPLICATION_JSON) @Consumes(MediaType.APPLICATION_JSON) public class CommonController { // Injection du servie commun pour toutes les op\u00e9rations de CRUD. @Inject private CommonService service; public CommonController() { } // CREATE // 1er param\u00e8tre: L'\u00e9l\u00e9ment de l'URL dynamique en fonction du nom de l'entit\u00e9 cible. // 2e param\u00e8tre: Corps de la requ\u00eate, contient le JSON de l'entit\u00e9 \u00e0 cr\u00e9er. @POST @Path(\"{type}/create\") public Response create( @PathParam(\"type\") final String type, final String jsonEntity) { var entity = DynamicEntityMapper.mapToEntity(type, jsonEntity); service.save(entity); return Response .status(Response.Status.CREATED) .build(); } // UPDATE // 1er param\u00e8tre: L'\u00e9l\u00e9ment de l'URL dynamique en fonction du nom de l'entit\u00e9 cible. // 2e param\u00e8tre: Corps de la requ\u00eate, contient le JSON de l'entit\u00e9 \u00e0 mettre \u00e0 jour. @PUT @Path(\"{type}/update\") public Response update( @PathParam(\"type\") final String type, final String jsonEntity) { var entity = DynamicEntityMapper.mapToEntity(type, jsonEntity); service.save(entity); return Response .status(Response.Status.NO_CONTENT) .build(); } // DELETE // 1er param\u00e8tre: L'\u00e9l\u00e9ment de l'URL dynamique en fonction du nom de l'entit\u00e9 cible. // 2e param\u00e8tre: Corps de la requ\u00eate, contient le JSON de l'entit\u00e9 \u00e0 supprimer. @DELETE @Path(\"{type}/remove\") public Response remove( @PathParam(\"type\") final String type, final String jsonEntity) { var entity = DynamicEntityMapper.mapToEntity(type, jsonEntity); service.remove(entity); return Response .status(Response.Status.NO_CONTENT) .build(); } // READ ALL // 1er param\u00e8tre: L'\u00e9l\u00e9ment de l'URL dynamique en fonction du nom de l'entit\u00e9 cible. @GET @Path(\"{type}/read\") public Response read(@PathParam(\"type\") final String type) { var entityClass = DynamicEntityMapper.mapToEntityClass(type); var entities = service.find(entityClass); return Response .status(Response.Status.OK) .entity(entities) .build(); } // READ // 1er param\u00e8tre: L'\u00e9l\u00e9ment de l'URL dynamique en fonction du nom de l'entit\u00e9 cible. // 2e param\u00e8tre: Clef primaire de l'entit\u00e9 cible. @GET @Path(\"{type}/read/{id}\") public Response read( @PathParam(\"type\") final String type, @PathParam(\"id\") final String id) { var entityClass = DynamicEntityMapper.mapToEntityClass(type); var identifier = DynamicEntityMapper.mapToEntityId(type, id); return service .findById(entityClass, identifier) .map(e -> Response.ok(e).build()) .orElseGet(() -> Response.status(Response.Status.NOT_FOUND).build()); } } Gestion des exceptions Pour terminer ce projet, voici une mani\u00e8re de g\u00e9rer les exceptions avec JAXRS . package fr.zelmoacademy.dyna.common.controller; import ...; // JAXRS: Cette classe est appel\u00e9e automatiquement lorsqu'une exception de type 'RuntimeException' survient. @Provider public class GenericExceptionMapper implements ExceptionMapper<RuntimeException> { public GenericExceptionMapper() { } @Override public Response toResponse(final RuntimeException exception) { //TODO: Faire de la journalisation ici... // Pour respecter le format d'\u00e9change JSON de l'API REST. // en cas d'erreur on retourne un objet JSON. var message = Json .createObjectBuilder() .add(\"error\", exception.getClass().getCanonicalName()) .add(\"message\", exception.getMessage()) .build(); return Response .status(Response.Status.BAD_REQUEST) .type(MediaType.APPLICATION_JSON) .entity(message) .build(); } } Note Ceci n'est qu'un exemple g\u00e9n\u00e9rique. Dans la r\u00e9alit\u00e9, il conviendra de capturer les erreurs avec de type bien d\u00e9finit au lieu de java.lang.RuntimeException . Usage Voici quelques commandes pour interroger l'application: Cr\u00e9ation : curl -X POST \\ http://localhost:8080/dyna/api/v1/entity/customer/create \\ -H 'Content-Type: application/json' \\ -d '{\"givenName\": \"John\", \"familyName\": \"DOE\", \"email\": \"john.doe @sample.org\"}' **Lecture :** <code bash> curl -X GET \\ http://localhost:8080/dyna/api/v1/entity/customer/read\\ -H 'Content-Type: application/json' \\ >>> '[{ \"email\": \"john.doe @sample.org\", \"familyName\": \"DOE\", \"givenName\": \"John\", \"id\": \"cc32378c-784c-49be-926a-930c1d37f6cd\", \"version\": \"0\" }]' Mise \u00e0 jour : curl -X PUT \\ http://localhost:8080/dyna/api/v1/entity/customer/update\\ -H 'Content-Type: application/json' \\ -d '{ \"givenName\": \"Johnny\", \"familyName\": \"TEST\", \"email\": \"johnny.test@sample.org\", \"id\": \"cc32378c-784c-49be-926a-930c1d37f6cd\", \"version\": \"0\" }' //Attention commande multi ligne.// **Suppression :** <code bash> curl -X DELETE \\ http://localhost:8080/dyna/api/v1/entity/customer/remove/cc32378c-784c-49be-926a-930c1d37f6cd \\ -H 'Content-Type: application/json' \\ Exemple de message d'erreur (Json malform\u00e9) : { \"error\":\"javax.json.stream.JsonParsingException\", \"message\":\"Internal error: Unexpected char -1 at (line no=1, column no=240, offset=239)\" } Pas terrible en effet... Axe d'am\u00e9lioration Ajouter une meilleure gestion des exceptions, car dans l'exemple, le message laisse trahir le fonctionnement interne de l'application. Ajouter un m\u00e9canisme de s\u00e9curisation de l'API. Ajouter un m\u00e9canisme pour prendre en compte des r\u00e8gles m\u00e9tiers sp\u00e9cifiques. Ajouter un filtre dynamique pour avoir une granularit\u00e9 plus fine lors des requ\u00eates vers l'API (jusqu'au niveau d'un attribut). => Principe de juste suffisance. Conclusion Voici un exemple minimaliste de CRUD en Jakarta EE 8 . Pour ajouter de nouvelle entit\u00e9 \u00e0 votre CRUD compl\u00e9ter simplement l'\u00e9num\u00e9ration DynamicEntity .","title":"Projet de synth\u00e8se"},{"location":"java/project_crud/#projet-de-synthese","text":"","title":"Projet de synth\u00e8se"},{"location":"java/project_crud/#introduction","text":"L'objectif de cet article est de r\u00e9aliser une application REST ( RE presentational S tate T ransfer) en Java avec les technologies Jakarta EE 8 . Le format d'\u00e9change de donn\u00e9e sera JSON ( J ava S cript O bject N otation) . Il s\u2019agira d'une simple application CRUD * ( C reate R ead U pade D* elete) . Sans logique m\u00e9tier particulier. Nom de code : Dyna Une application dynamique et g\u00e9n\u00e9rique pour les op\u00e9rations de CRUD .","title":"Introduction"},{"location":"java/project_crud/#preparatif","text":"Pour r\u00e9aliser ce projet, nous utiliserons : Java 11 Payara Server 5.X Maven 3.6.X Pas besoin de biblioth\u00e8que logicielle suppl\u00e9mentaire. Arborescence du projet : + fr.zelmoacademy.dyna + common - controller - persistence - service - util - feature1 - feature2 - ... L\u00e9gende: * fr.zelmoacademy.dyna : package racine du projet. * common : Partie commune de tout le projet (c'est ici que nous travaillerons). * controller : Partie contr\u00f4leur REST . * persistence : Partie mod\u00e8le et persistance en base de donn\u00e9es. * service : Partie traitement applicatif. * util / Classe utilitaire. * feature1 , feature2 , ... : Partie sp\u00e9cifique \u00e0 une zone fonctionnelle. Note Afin de simplifier la structure du projet, l'application sera une archive de type WAR . Mais rien ne vous emp\u00eache d'utiliser le format EAR .","title":"Pr\u00e9paratif"},{"location":"java/project_crud/#couche-de-persistance","text":"","title":"Couche de persistance"},{"location":"java/project_crud/#entite","text":"Pour r\u00e9duire la quantit\u00e9 de ligne de code, les entit\u00e9s persistances seront manipul\u00e9es dans toutes les couches de notre architecture logicielle. Pour cela nous utiliserons les annotations Jakarta EE pour : * R\u00e9aliser la liaison avec la base donn\u00e9es (avec JPA . * R\u00e9aliser la conversion au format JSON (avec JSON-B ). * Porter les contraintes de validation des attributs (avec BeanValidation ). Afin de regrouper nos entit\u00e9s sous une m\u00eame hi\u00e9rarchie de classe, nous codons cette interface commune \u00e0 toutes les entit\u00e9s: package fr.zelmoacademy.dyna.common.persistence; // Utilisation de la g\u00e9n\u00e9ricit\u00e9 pour typer la clef primaire. public interface Identifiable<K> { // V\u00e9rifie l'\u00e9tat de la clef primaire. // Si la valeur n'est pas d\u00e9finie, elle sera alors g\u00e9n\u00e9r\u00e9e. // Sera utile plus tard pour diff\u00e9rencier une cr\u00e9ation d'une mise \u00e0 jour. void checkId(); // Simple accesseur & mutateur de la clef primaire. K getId(); void setId(K id); } Pour plus de facilit\u00e9, voici un exemple de classe m\u00e8re afin de factoriser du code : package fr.zelmoacademy.dyna.common.persistence; import ... // JSON-B: Trier les attributs par ordre alphab\u00e9tique @JsonbPropertyOrder(PropertyOrderStrategy.LEXICOGRAPHICAL) // JPA: Indique que les attributs de cette classe seront fusionn\u00e9s dans la table SQL enfant. @MappedSuperclass // Impl\u00e9menter 'Identifiable' avec une clef primaire de type 'UUID'. public abstract class AbstractEntity implements Identifiable<UUID>, Serializable { // Num\u00e9ro de s\u00e9rie pour respecter le m\u00e9canisme de s\u00e9rialisation. private static final long serialVersionUID = 1L; // BeanValidation: Contrainte non nulle. @NotNull // JSON-B: Nom et contrainte de l'attribut pour le format JSON. @JsonbProperty(value = \"id\", nillable = true) // JPA: Clef primaire @Id // JPA: Nom et contrainte de la colonne en base de donn\u00e9es. // /!\\ Ce type n'est pas g\u00e9r\u00e9 nativement par JPA, on explicite le type SQL 'VARCHAR(36)'. @Column(name = \"id\", nullable = false, unique = true, columnDefinition = \"VARCHAR(36)\") protected UUID id; // BeanValidation: Contrainte non nulle. @NotNull // JSON-B: Nom et contrainte de l'attribut pour le format JSON. @JsonbProperty(value = \"version\", nillable = true) // JPA: Num\u00e9ro de version du tuple en base de donn\u00e9es, s'incr\u00e9mente \u00e0 chaque modification. @Version // JPA: Nom et contrainte de la colonne en base de donn\u00e9es. @Column(name = \"version\", nullable = false) protected Long version; // Java Bean: Constructeur par d\u00e9faut. protected AbstractEntity() { this.id = UUID.randomUUID(); this.version = 0L; } // Surchage des m\u00e9thodes: 'equals', 'hashCode', 'toString' // ... @Override public void checkId(){ // Dans notre cas, c'est l'application qui assure // l'int\u00e9grit\u00e9 de la clef primaire. if(Objects.isNull(id){ id = UUID.randomUUID(); } if(Objects.isNull(version){ version = 0L; } } // Accesseurs & Mutateurs // ... } Exemple d'entit\u00e9 concr\u00e8te : package fr.zelmoacademy.dyna.customer; import ...; // CDI: Cette classe est injectable @Dependent // JSON-B: Trier les attributs par ordre alphab\u00e9tique @JsonbPropertyOrder(PropertyOrderStrategy.LEXICOGRAPHICAL) // JPA: Entit\u00e9 persistante li\u00e9e \u00e0 la table 'customer' en base de donn\u00e9es. @Entity @Table(name = \"customer\") public class Customer extends AbstractEntity { private static final long serialVersionUID = 1L; // BeanValidation: Contrainte non vide. @NotBlank // JSON-B: Nom et contrainte de l'attribut pour le format JSON. @JsonbProperty(value = \"givenName\", nillable = false) // JPA: Nom et contrainte de la colonne en base de donn\u00e9es. @Column(name = \"given_name\", nullable = false) private String givenName; // BeanValidation: Contrainte non vide. @NotBlank // JSON-B: Nom et contrainte de l'attribut pour le format JSON. @JsonbProperty(value = \"familyName\", nillable = false) // JPA: Nom et contrainte de la colonne en base de donn\u00e9es. @Column(name = \"family_name\", nullable = false) private String familyName; // BeanValidation: Contrainte, format adresse de courriel et non vide. @Email @NotBlank // JSON-B: Nom et contrainte de l'attribut pour le format JSON. @JsonbProperty(value = \"email\", nillable = false) // JPA: Nom et contrainte de la colonne en base de donn\u00e9es. @Column(name = \"email\", nullable = false, unique = true) private String email; public Customer() { } // Surchage des m\u00e9thodes: 'equals', 'hashCode', 'toString' // ... // Accesseurs & Mutateurs // ... }","title":"Entit\u00e9"},{"location":"java/project_crud/#convertisseur-dattribut","text":"Le type java.util.UUID n'est pas g\u00e9n\u00e9r\u00e9 nativement par JPA . Il est n\u00e9cessaire de coder un convertisseur de type. Dans notre code, on convertira le type java.util.UUID en java.lang.String . package fr.zelmoacademy.dyna.common.persistence; import ...; // Applique le convertisseur automatiquent pour tous les attributs JPA de type 'java.util.UUID'. @Converter(autoApply = true) public class UUIDConverter implements AttributeConverter<UUID, String> { public static final String COLUMN_DEFINITION = \"VARCHAR(36)\"; public UUIDConverter() { } // Convertir un attribut en colonne de base de donn\u00e9es. @Override public String convertToDatabaseColumn(UUID attribute) { String column; if (Objects.nonNull(attribute)) { column = attribute.toString(); } else { column = null; } return column; } // Convertir une colonne de base de donn\u00e9es en attribut. @Override public UUID convertToEntityAttribute(String column) { UUID attribute; if (Objects.nonNull(column)) { attribute = UUID.fromString(column); } else { attribute = null; } return attribute; } }","title":"Convertisseur d'attribut"},{"location":"java/project_crud/#alignement-cdi","text":"La technologie CDI ( C ontext D ependency I njection) est une technologie qui prend de l'ampleur dans Jakarta EE . A ce titre nous pouvons unifier les injections de d\u00e9pendance \u00e0 travers CDI. package fr.zelmoacademy.dyna.common.persistence; import ...; // Cette classe est initialis\u00e9e au d\u00e9marrage de l'application. @ApplicationScoped public class PersistenceResource { // Gestionnaire d'entit\u00e9 injectable avec CDI @Produces @PersistenceContext private EntityManager em; public PersistenceResource() { } } Gr\u00e2ce \u00e0 cette classe vous pouvez utiliser l'annotation @Inject sur un attribut de type javax.persistence.EntityManager .","title":"Alignement CDI"},{"location":"java/project_crud/#entrepot","text":"package fr.zelmoacademy.dyna.common.persistence; import ...; // Entrep\u00f4t de donn\u00e9es g\u00e9n\u00e9rique & polymorphique // Le pattern 'Repository/DAO' doit \u00e0 l'usage avoir le m\u00eame comportement qu'une 'Collection/List' en Java. // Comme cette classe s'adapte \u00e0 la plupart des entit\u00e9s persistantes, les types manipul\u00e9s seront donc // polymorph\u00e9 avec 'Identifiable' afin d\u2019assurer un minimum de typage. // Cette classe est injectable avec CDI. @Dependent public class GenericDAO implements Serializable { // Num\u00e9ro de s\u00e9rie pour respecter la s\u00e9rialisation. private static final long serialVersionUID = 1L; // JPA: Gestionnaire d'entit\u00e9 @Inject private transient EntityManager em; public GenericDAO() { } // R\u00e9cup\u00e9rer le nombre d'occurrence en base de donn\u00e9es pour une entit\u00e9 donn\u00e9e. public Long size(final Class<? extends Identifiable<?>> entityClass) { // SQL: // SELECT count(t.id) FROM table t; var builder = em.getCriteriaBuilder(); var query = builder.createQuery(Long.class); var root = query.from(entityClass); query.select(builder.count(root)); return em.createQuery(query).getSingleResult(); } // Indique si la table associ\u00e9e \u00e0 une entit\u00e9 est vide. public boolean isEmpty(final Class<? extends Identifiable<?>> entityClass) { return size(entityClass) == 0L; } // V\u00e9rifier d'une entit\u00e9 existe d\u00e9j\u00e0 en base de donn\u00e9es. public boolean contains(final Identifiable<?> entity) { var entityClass = entity.getClass(); boolean exists; if (em.contains(entity)) { // V\u00e9rification de l\u2019existence de l'entit\u00e9 dans le contexte de persistance. // (plus rapide qu'une requ\u00eate) exists = true; } else { // Sinon // Requ\u00eater en base de donn\u00e9es. // SQL: // SELECT count(t.id) FROM table t WHERE t.id = ?; var builder = em.getCriteriaBuilder(); var query = builder.createQuery(Long.class); var root = query.from(entityClass); query.select(builder.count(root)); var idTypeName = getIdentifierTypeName(entity); var predicate = builder.equal(root.get(idTypeName), entity.getId()); query.where(predicate); exists = em.createQuery(query).getSingleResult() == 1L; } return exists; } // Sauvegarder une entit\u00e9 // Si elle existe d\u00e9j\u00e0, la mettre \u00e0 jour en base de donn\u00e9es // Sinon l'ins\u00e9rer en base de donn\u00e9es. public Identifiable<?> add(final Identifiable<?> entity) { Identifiable<?> mangedEntity; if (contains(entity)) { // Mettre \u00e0 jour mangedEntity = em.merge(entity); } else { // Ins\u00e9rer en base de donn\u00e9es. em.persist(entity); mangedEntity = entity; } return mangedEntity; } // Supprimer une entit\u00e9 // SQL: // DELETE FROM table t WHERE t.id = ?; public void remove(final Identifiable<?> entity) { var entityClass = entity.getClass(); var id = getIdentifier(entity); var attachedEntity = em.getReference(entityClass, id); em.remove(attachedEntity); CDI.current().destroy(attachedEntity); } // Rechercher toutes les entit\u00e9s d'un type donn\u00e9: // /!\\ Peut remonter beaucoup d'objet et saturer la m\u00e9moire ! // SELECT t.col1, t.col2, t.col3, ... FROM table t; public List<? extends Identifiable<?>> get(final Class<? extends Identifiable<?>> entityClass) { var builder = em.getCriteriaBuilder(); var query = builder.createQuery(entityClass); return em .createQuery(query) .getResultList(); } // Rechercher une entit\u00e9 d'un type donn\u00e9 en fonction de son identifiant. public Optional<Identifiable<?>> get(final Class<? extends Identifiable<?>> entityClass, final Object id) { // Lecture dans le cache de persistance. var entity = em.find(entityClass, id); return Optional.ofNullable(entity); } // M\u00e9thode interne: // R\u00e9cup\u00e9rer dynamiquement la valeur de la clef primaire. private <K> K getIdentifier(final Identifiable<K> entity) { return (K) em .getEntityManagerFactory() .getPersistenceUnitUtil() .getIdentifier(entity); } // M\u00e9thode interne: // R\u00e9cup\u00e9rer dynamiquement le nom de l'attribut de la clef primaire. private String getIdentifierTypeName(final Identifiable<?> entity) { var entityClass = entity.getClass(); var id = getIdentifier(entity); var idClass = id.getClass(); return em .getMetamodel() .entity(entityClass) .getId(idClass) .getName(); } }","title":"Entrep\u00f4t"},{"location":"java/project_crud/#couche-de-services","text":"Le service m\u00e9tier ne poss\u00e8de pas de logique particuli\u00e8re. Son travail consiste principalement \u00e0 de la d\u00e9l\u00e9gation de m\u00e9thode. package fr.zelmoacademy.dyna.common.service; import ...; // Classe de service g\u00e9n\u00e9rique pour les op\u00e9rations de CRUD // Pas de logique particuli\u00e8re. // Simple appel de la DAO. // EJB: Indique que cette classe est sans \u00e9tat. @Stateless @LocalBean public class CommonService implements Serializable { // Num\u00e9ro de s\u00e9rie. private static final long serialVersionUID = 1L; // CDI: Injection de l'entrep\u00f4t de donn\u00e9e g\u00e9n\u00e9rique. @Inject private GenericDAO dao; // Java Bean: Constructeur par d\u00e9faut. public CommonService() { } // JTA:Java Transaction API // Gestionnaire de transaction // Par d\u00e9faut le EJB g\u00e8rent automatiquement les transactions // Mais dans de rare cas, il peut \u00eatre n\u00e9cessaire de de d\u00e9finir ce comportement soit-m\u00eame // JTA: Indique que cette m\u00e9thode requiert une nouvelle transaction. // Exemple: @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW) public void save(final Identifiable<?> entity) { // Si la clef primaire n'est pas d\u00e9finie, alors elle est g\u00e9n\u00e9r\u00e9e // Permet de distinguer la cr\u00e9ation d'une mise \u00e0 jour entity.checkId(); dao.add(entity); } // JTA: Indique que cette m\u00e9thode requiert une transaction. // Exemple: @TransactionAttribute(TransactionAttributeType.REQUIRED) public void remove(final Identifiable<?> entity) { dao.remove(entity); } // JTA: Indique que cette m\u00e9thode n'est pas besoin de transaction (lecture seule en base de donn\u00e9es) // Exemple: @TransactionAttribute(TransactionAttributeType.NEVER) public Optional<? extends Identifiable<?>> findById( final Class<? extends Identifiable<?>> entityClass, final Object id) { return dao.get(entityClass, id); } // JTA: Indique que cette m\u00e9thode n'est pas besoin de transaction (lecture seule en base de donn\u00e9es) // Exemple: @TransactionAttribute(TransactionAttributeType.NEVER) public List<? extends Identifiable<?>> find(final Class<? extends Identifiable<?>> entityClass) { return dao.get(entityClass); } }","title":"Couche de services"},{"location":"java/project_crud/#variante-cdi","text":"Variante de cette classe mais avec la technologie CDI . package fr.zelmoacademy.dyna.common.service; import ...; // Classe de service g\u00e9n\u00e9rique pour les op\u00e9rations de CRUD // Pas de logique particuli\u00e8re. // Simple appel de la DAO. // CDI: Instance charge au d\u00e9marrage de l'application et dans un r\u00e9gime transactionnel @ApplicationScoped @Transactional public class CommonService { // CDI: Injection de l'entrep\u00f4t de donn\u00e9e g\u00e9n\u00e9rique. @Inject private GenericDAO dao; // Java Bean: Constructeur par d\u00e9faut. public CommonService() { } // JTA:Java Transaction API // Gestionnaire de transaction // Par d\u00e9faut le CDI NE g\u00e8rent PAS automatiquement les transactions // Il est n\u00e9cessaire d'ajouter l'annotation @Transactional pour avoir un comportement // similaire aux EJB. // Dans de rare cas, il peut \u00eatre n\u00e9cessaire de de d\u00e9finir ce comportement soit-m\u00eame // Pour cela, il suffit de porter l'annotation @Transactional sur les m\u00e9thodes. // Exiger une nouvelle transaction pour m\u00e9thode. // M\u00eame logique pour EJB, seule l'annotation diff\u00e8re. // Exemple: @Transactional(Transactional.TxType.REQUIRES_NEW) public void save(final Identifiable<?> entity) { ... } // Autres m\u00e9thodes // ... } Note Effectivement, les EJB ne sont plus aussi indispensable qu'avant. Cette nouvelle \u00e9criture est valable depuis Java EE 7 . Source: [[https://blogs.oracle.com/theaquarium/jta-12-its-not-your-grandfathers-transactions-anymore | Blog Oracle]]","title":"Variante CDI"},{"location":"java/project_crud/#couche-de-controle","text":"","title":"Couche de contr\u00f4le"},{"location":"java/project_crud/#entite-dynamique","text":"Nous allons mettre en \u0153uvre une \u00e9num\u00e9ration qui va porter en lui toute la sp\u00e9cificit\u00e9 de notre CRUD . Il arrive un stade o\u00f9 on ne peut plus \u00eatre g\u00e9n\u00e9rique, afin de simplifier le code aux maximum, cette partie sp\u00e9cifique va se limiter \u00e0 une seule classe. package fr.zelmoacademy.dyna; import ...; public enum DynamicEntity { // Exemple CUSTOMER(\"customer\", Customer.class, UUID::fromString); // Nom REST de l'entit\u00e9 cible pour le CRUD. // Ce nom est celui qui apparait dans l'URL. private final String name; // Type Java de l'entit\u00e9 private final Class<? extends Identifiable<?>> entityClass; // Fonction g\u00e9n\u00e9rique de conversion de la clef primaire // Depuis l'API, il arrive sous le type 'String' // cette fonction permet de le convertir sous un autre type // par exemple 'UUID' (voir exemple) private final Function<String, Object> identifierConverter; DynamicEntity( final String name, final Class<? extends Identifiable<?>> entityClass, final Function<String, Object> identifierConverter) { this.name = name; this.entityClass = entityClass; this.identifierConverter = identifierConverter; } // A partir du nom de l'entit\u00e9 // Rechercher la valeur de l'enum\u00e9ration correspondante. public static Optional<DynamicEntity> fromName(final String name) { return Stream .of(DynamicEntity.values()) .filter(e -> Objects.equals(e.name, name)) .findFirst(); } // Convertir une clef primaire de type 'String' // en autre autre type (polymorph\u00e9 en 'Object') public Object convertAsIdentifier(final String id) { return identifierConverter.apply(id); } // Accesseurs public String getName() { return name; } public Class<? extends Identifiable<?>> getEntityClass() { return entityClass; } } Note A pr\u00e9sent, lorsque le d\u00e9veloppeur souhaite ajouter une entit\u00e9 dans le CRUD , il suffira d'ajouter une entr\u00e9e dans cette \u00e9num\u00e9ration. Exemple: CUSTOMER(\"customer\", Customer.class, UUID::fromString) .","title":"Entit\u00e9 dynamique"},{"location":"java/project_crud/#convertisseur-dynamique","text":"Depuis notre API pour \u00eatre g\u00e9n\u00e9rique, nous recevons les donn\u00e9es sous forme de texte, sous java.lang.String en Java. Mais pour que l'application fonctionne correctement, nous avons besoin de convertir ces donn\u00e9es dans les bons types. Bien entendu, les types r\u00e9els seront polymorph\u00e9 en type abstrait pour conserver la g\u00e9n\u00e9ricit\u00e9. package fr.zelmoacademy.dyna.common.controller; import ...; public final class DynamicEntityMapper { // Constructeur interne. // Pas d'instanciation. private DynamicEntityMapper() { throw new UnsupportedOperationException(\"Instance not allowed\"); } // Convertir un 'String JSON' en entit\u00e9 (polymorph\u00e9 en 'Identifiable') // Si le type n'existe pas, une exception sera lev\u00e9e. public static Identifiable<?> mapToEntity(final String type, final String jsonEntity) { return DynamicEntity .fromName(type) .map(DynamicEntity::getEntityClass) .map(e -> JsonbBuilder.create().fromJson(jsonEntity, e)) .orElseThrow(() -> new WebApplicationException(\"Invalid entity\")); } // Convertir le nom du type en la classe Java de l'entit\u00e9. // Si le type n'existe pas, une exception sera lev\u00e9e. public static Class<? extends Identifiable<?>> mapToEntityClass(final String type) { return DynamicEntity .fromName(type) .map(DynamicEntity::getEntityClass) .orElseThrow(() -> new WebApplicationException(\"Invalid entity\")); } // Convertir un 'String' de la clef primaire en un autre type // en fonction du nom du type d'entit\u00e9. // Si le type n'existe pas, une exception sera lev\u00e9e. public static Object mapToEntityId(final String type, final String id) { return DynamicEntity .fromName(type) .map(e -> e.convertAsIdentifier(id)) .orElseThrow(() -> new WebApplicationException(\"Invalid entity\")); } }","title":"Convertisseur dynamique"},{"location":"java/project_crud/#controleur","text":"Pour utiliser les contr\u00f4leurs REST en Jakarta EE, une simple classe de configuration est n\u00e9cessaire: package fr.zelmoacademy.dyna.common.controller; import ...; // JAXRS: Chemin racine de toute l'API. @ApplicationPath(\"api\") public class RESTConfiguration extends Application { public RESTConfiguration() { } // RAS // Tout se configure avec les annotations. } Enfin, voici le contr\u00f4leur unique pour toutes les op\u00e9rations de CRUD . package fr.zelmoacademy.dyna.common.controller; import ...; // Cette classe est injectable // La dur\u00e9e de vie de l'instance est celui d'une requ\u00eate HTTP. @RequestScoped // Chemin de base du contr\u00f4leur @Path(\"v1/entity\") // Indique que le contr\u00f4leur produit et consomme du JSON. @Produces(MediaType.APPLICATION_JSON) @Consumes(MediaType.APPLICATION_JSON) public class CommonController { // Injection du servie commun pour toutes les op\u00e9rations de CRUD. @Inject private CommonService service; public CommonController() { } // CREATE // 1er param\u00e8tre: L'\u00e9l\u00e9ment de l'URL dynamique en fonction du nom de l'entit\u00e9 cible. // 2e param\u00e8tre: Corps de la requ\u00eate, contient le JSON de l'entit\u00e9 \u00e0 cr\u00e9er. @POST @Path(\"{type}/create\") public Response create( @PathParam(\"type\") final String type, final String jsonEntity) { var entity = DynamicEntityMapper.mapToEntity(type, jsonEntity); service.save(entity); return Response .status(Response.Status.CREATED) .build(); } // UPDATE // 1er param\u00e8tre: L'\u00e9l\u00e9ment de l'URL dynamique en fonction du nom de l'entit\u00e9 cible. // 2e param\u00e8tre: Corps de la requ\u00eate, contient le JSON de l'entit\u00e9 \u00e0 mettre \u00e0 jour. @PUT @Path(\"{type}/update\") public Response update( @PathParam(\"type\") final String type, final String jsonEntity) { var entity = DynamicEntityMapper.mapToEntity(type, jsonEntity); service.save(entity); return Response .status(Response.Status.NO_CONTENT) .build(); } // DELETE // 1er param\u00e8tre: L'\u00e9l\u00e9ment de l'URL dynamique en fonction du nom de l'entit\u00e9 cible. // 2e param\u00e8tre: Corps de la requ\u00eate, contient le JSON de l'entit\u00e9 \u00e0 supprimer. @DELETE @Path(\"{type}/remove\") public Response remove( @PathParam(\"type\") final String type, final String jsonEntity) { var entity = DynamicEntityMapper.mapToEntity(type, jsonEntity); service.remove(entity); return Response .status(Response.Status.NO_CONTENT) .build(); } // READ ALL // 1er param\u00e8tre: L'\u00e9l\u00e9ment de l'URL dynamique en fonction du nom de l'entit\u00e9 cible. @GET @Path(\"{type}/read\") public Response read(@PathParam(\"type\") final String type) { var entityClass = DynamicEntityMapper.mapToEntityClass(type); var entities = service.find(entityClass); return Response .status(Response.Status.OK) .entity(entities) .build(); } // READ // 1er param\u00e8tre: L'\u00e9l\u00e9ment de l'URL dynamique en fonction du nom de l'entit\u00e9 cible. // 2e param\u00e8tre: Clef primaire de l'entit\u00e9 cible. @GET @Path(\"{type}/read/{id}\") public Response read( @PathParam(\"type\") final String type, @PathParam(\"id\") final String id) { var entityClass = DynamicEntityMapper.mapToEntityClass(type); var identifier = DynamicEntityMapper.mapToEntityId(type, id); return service .findById(entityClass, identifier) .map(e -> Response.ok(e).build()) .orElseGet(() -> Response.status(Response.Status.NOT_FOUND).build()); } }","title":"Contr\u00f4leur"},{"location":"java/project_crud/#gestion-des-exceptions","text":"Pour terminer ce projet, voici une mani\u00e8re de g\u00e9rer les exceptions avec JAXRS . package fr.zelmoacademy.dyna.common.controller; import ...; // JAXRS: Cette classe est appel\u00e9e automatiquement lorsqu'une exception de type 'RuntimeException' survient. @Provider public class GenericExceptionMapper implements ExceptionMapper<RuntimeException> { public GenericExceptionMapper() { } @Override public Response toResponse(final RuntimeException exception) { //TODO: Faire de la journalisation ici... // Pour respecter le format d'\u00e9change JSON de l'API REST. // en cas d'erreur on retourne un objet JSON. var message = Json .createObjectBuilder() .add(\"error\", exception.getClass().getCanonicalName()) .add(\"message\", exception.getMessage()) .build(); return Response .status(Response.Status.BAD_REQUEST) .type(MediaType.APPLICATION_JSON) .entity(message) .build(); } } Note Ceci n'est qu'un exemple g\u00e9n\u00e9rique. Dans la r\u00e9alit\u00e9, il conviendra de capturer les erreurs avec de type bien d\u00e9finit au lieu de java.lang.RuntimeException .","title":"Gestion des exceptions"},{"location":"java/project_crud/#usage","text":"Voici quelques commandes pour interroger l'application: Cr\u00e9ation : curl -X POST \\ http://localhost:8080/dyna/api/v1/entity/customer/create \\ -H 'Content-Type: application/json' \\ -d '{\"givenName\": \"John\", \"familyName\": \"DOE\", \"email\": \"john.doe @sample.org\"}' **Lecture :** <code bash> curl -X GET \\ http://localhost:8080/dyna/api/v1/entity/customer/read\\ -H 'Content-Type: application/json' \\ >>> '[{ \"email\": \"john.doe @sample.org\", \"familyName\": \"DOE\", \"givenName\": \"John\", \"id\": \"cc32378c-784c-49be-926a-930c1d37f6cd\", \"version\": \"0\" }]' Mise \u00e0 jour : curl -X PUT \\ http://localhost:8080/dyna/api/v1/entity/customer/update\\ -H 'Content-Type: application/json' \\ -d '{ \"givenName\": \"Johnny\", \"familyName\": \"TEST\", \"email\": \"johnny.test@sample.org\", \"id\": \"cc32378c-784c-49be-926a-930c1d37f6cd\", \"version\": \"0\" }' //Attention commande multi ligne.// **Suppression :** <code bash> curl -X DELETE \\ http://localhost:8080/dyna/api/v1/entity/customer/remove/cc32378c-784c-49be-926a-930c1d37f6cd \\ -H 'Content-Type: application/json' \\ Exemple de message d'erreur (Json malform\u00e9) : { \"error\":\"javax.json.stream.JsonParsingException\", \"message\":\"Internal error: Unexpected char -1 at (line no=1, column no=240, offset=239)\" } Pas terrible en effet...","title":"Usage"},{"location":"java/project_crud/#axe-damelioration","text":"Ajouter une meilleure gestion des exceptions, car dans l'exemple, le message laisse trahir le fonctionnement interne de l'application. Ajouter un m\u00e9canisme de s\u00e9curisation de l'API. Ajouter un m\u00e9canisme pour prendre en compte des r\u00e8gles m\u00e9tiers sp\u00e9cifiques. Ajouter un filtre dynamique pour avoir une granularit\u00e9 plus fine lors des requ\u00eates vers l'API (jusqu'au niveau d'un attribut). => Principe de juste suffisance.","title":"Axe d'am\u00e9lioration"},{"location":"java/project_crud/#conclusion","text":"Voici un exemple minimaliste de CRUD en Jakarta EE 8 . Pour ajouter de nouvelle entit\u00e9 \u00e0 votre CRUD compl\u00e9ter simplement l'\u00e9num\u00e9ration DynamicEntity .","title":"Conclusion"}]}